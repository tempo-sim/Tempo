// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TempoMovement/MovementControlService.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_TempoMovement_2fMovementControlService_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_TempoMovement_2fMovementControlService_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "TempoScripting/Empty.pb.h"
#include "TempoScripting/Geometry.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_TempoMovement_2fMovementControlService_2eproto TEMPOMOVEMENT_API

namespace google {
namespace protobuf_tempo {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf_tempo
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TEMPOMOVEMENT_API TableStruct_TempoMovement_2fMovementControlService_2eproto {
  static const ::uint32_t offsets[];
};
TEMPOMOVEMENT_API extern const ::google::protobuf_tempo::internal::DescriptorTable
    descriptor_table_TempoMovement_2fMovementControlService_2eproto;
namespace TempoMovement {
class CommandablePawnsResponse;
struct CommandablePawnsResponseDefaultTypeInternal;
TEMPOMOVEMENT_API extern CommandablePawnsResponseDefaultTypeInternal _CommandablePawnsResponse_default_instance_;
class CommandableVehiclesResponse;
struct CommandableVehiclesResponseDefaultTypeInternal;
TEMPOMOVEMENT_API extern CommandableVehiclesResponseDefaultTypeInternal _CommandableVehiclesResponse_default_instance_;
class PawnMoveToLocationRequest;
struct PawnMoveToLocationRequestDefaultTypeInternal;
TEMPOMOVEMENT_API extern PawnMoveToLocationRequestDefaultTypeInternal _PawnMoveToLocationRequest_default_instance_;
class PawnMoveToLocationResponse;
struct PawnMoveToLocationResponseDefaultTypeInternal;
TEMPOMOVEMENT_API extern PawnMoveToLocationResponseDefaultTypeInternal _PawnMoveToLocationResponse_default_instance_;
class VehicleCommandRequest;
struct VehicleCommandRequestDefaultTypeInternal;
TEMPOMOVEMENT_API extern VehicleCommandRequestDefaultTypeInternal _VehicleCommandRequest_default_instance_;
}  // namespace TempoMovement
namespace google {
namespace protobuf_tempo {
}  // namespace protobuf_tempo
}  // namespace google

namespace TempoMovement {
enum MoveToResult : int {
  UNKNOWN = 0,
  SUCCESS = 1,
  BLOCKED = 2,
  OFF_PATH = 3,
  ABORTED = 4,
  INVALID = 5,
  MoveToResult_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MoveToResult_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

TEMPOMOVEMENT_API bool MoveToResult_IsValid(int value);
TEMPOMOVEMENT_API extern const uint32_t MoveToResult_internal_data_[];
constexpr MoveToResult MoveToResult_MIN = static_cast<MoveToResult>(0);
constexpr MoveToResult MoveToResult_MAX = static_cast<MoveToResult>(5);
constexpr int MoveToResult_ARRAYSIZE = 5 + 1;
TEMPOMOVEMENT_API const ::google::protobuf_tempo::EnumDescriptor*
MoveToResult_descriptor();
template <typename T>
const std::string& MoveToResult_Name(T value) {
  static_assert(std::is_same<T, MoveToResult>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MoveToResult_Name().");
  return MoveToResult_Name(static_cast<MoveToResult>(value));
}
template <>
inline const std::string& MoveToResult_Name(MoveToResult value) {
  return ::google::protobuf_tempo::internal::NameOfDenseEnum<MoveToResult_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool MoveToResult_Parse(absl_tempo::string_view name, MoveToResult* value) {
  return ::google::protobuf_tempo::internal::ParseNamedEnum<MoveToResult>(
      MoveToResult_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TEMPOMOVEMENT_API VehicleCommandRequest final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMovement.VehicleCommandRequest) */ {
 public:
  inline VehicleCommandRequest() : VehicleCommandRequest(nullptr) {}
  ~VehicleCommandRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleCommandRequest(::google::protobuf_tempo::internal::ConstantInitialized);

  inline VehicleCommandRequest(const VehicleCommandRequest& from)
      : VehicleCommandRequest(nullptr, from) {}
  VehicleCommandRequest(VehicleCommandRequest&& from) noexcept
    : VehicleCommandRequest() {
    *this = ::std::move(from);
  }

  inline VehicleCommandRequest& operator=(const VehicleCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleCommandRequest& operator=(VehicleCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleCommandRequest* internal_default_instance() {
    return reinterpret_cast<const VehicleCommandRequest*>(
               &_VehicleCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VehicleCommandRequest& a, VehicleCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleCommandRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleCommandRequest* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleCommandRequest>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const VehicleCommandRequest& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const VehicleCommandRequest& from) {
    VehicleCommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(VehicleCommandRequest* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMovement.VehicleCommandRequest";
  }
  protected:
  explicit VehicleCommandRequest(::google::protobuf_tempo::Arena* arena);
  VehicleCommandRequest(::google::protobuf_tempo::Arena* arena, const VehicleCommandRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleNameFieldNumber = 1,
    kAccelerationFieldNumber = 2,
    kSteeringFieldNumber = 3,
  };
  // string vehicle_name = 1;
  void clear_vehicle_name() ;
  const std::string& vehicle_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vehicle_name(Arg_&& arg, Args_... args);
  std::string* mutable_vehicle_name();
  PROTOBUF_NODISCARD std::string* release_vehicle_name();
  void set_allocated_vehicle_name(std::string* value);

  private:
  const std::string& _internal_vehicle_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicle_name(
      const std::string& value);
  std::string* _internal_mutable_vehicle_name();

  public:
  // float acceleration = 2;
  void clear_acceleration() ;
  float acceleration() const;
  void set_acceleration(float value);

  private:
  float _internal_acceleration() const;
  void _internal_set_acceleration(float value);

  public:
  // float steering = 3;
  void clear_steering() ;
  float steering() const;
  void set_steering(float value);

  private:
  float _internal_steering() const;
  void _internal_set_steering(float value);

  public:
  // @@protoc_insertion_point(class_scope:TempoMovement.VehicleCommandRequest)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      2, 3, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMOVEMENT_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::internal::ArenaStringPtr vehicle_name_;
    float acceleration_;
    float steering_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMovement_2fMovementControlService_2eproto;
};// -------------------------------------------------------------------

class TEMPOMOVEMENT_API PawnMoveToLocationResponse final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMovement.PawnMoveToLocationResponse) */ {
 public:
  inline PawnMoveToLocationResponse() : PawnMoveToLocationResponse(nullptr) {}
  ~PawnMoveToLocationResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PawnMoveToLocationResponse(::google::protobuf_tempo::internal::ConstantInitialized);

  inline PawnMoveToLocationResponse(const PawnMoveToLocationResponse& from)
      : PawnMoveToLocationResponse(nullptr, from) {}
  PawnMoveToLocationResponse(PawnMoveToLocationResponse&& from) noexcept
    : PawnMoveToLocationResponse() {
    *this = ::std::move(from);
  }

  inline PawnMoveToLocationResponse& operator=(const PawnMoveToLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PawnMoveToLocationResponse& operator=(PawnMoveToLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PawnMoveToLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PawnMoveToLocationResponse* internal_default_instance() {
    return reinterpret_cast<const PawnMoveToLocationResponse*>(
               &_PawnMoveToLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PawnMoveToLocationResponse& a, PawnMoveToLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PawnMoveToLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PawnMoveToLocationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PawnMoveToLocationResponse* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PawnMoveToLocationResponse>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const PawnMoveToLocationResponse& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const PawnMoveToLocationResponse& from) {
    PawnMoveToLocationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(PawnMoveToLocationResponse* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMovement.PawnMoveToLocationResponse";
  }
  protected:
  explicit PawnMoveToLocationResponse(::google::protobuf_tempo::Arena* arena);
  PawnMoveToLocationResponse(::google::protobuf_tempo::Arena* arena, const PawnMoveToLocationResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .TempoMovement.MoveToResult result = 1;
  void clear_result() ;
  ::TempoMovement::MoveToResult result() const;
  void set_result(::TempoMovement::MoveToResult value);

  private:
  ::TempoMovement::MoveToResult _internal_result() const;
  void _internal_set_result(::TempoMovement::MoveToResult value);

  public:
  // @@protoc_insertion_point(class_scope:TempoMovement.PawnMoveToLocationResponse)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMOVEMENT_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    int result_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMovement_2fMovementControlService_2eproto;
};// -------------------------------------------------------------------

class TEMPOMOVEMENT_API CommandableVehiclesResponse final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMovement.CommandableVehiclesResponse) */ {
 public:
  inline CommandableVehiclesResponse() : CommandableVehiclesResponse(nullptr) {}
  ~CommandableVehiclesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandableVehiclesResponse(::google::protobuf_tempo::internal::ConstantInitialized);

  inline CommandableVehiclesResponse(const CommandableVehiclesResponse& from)
      : CommandableVehiclesResponse(nullptr, from) {}
  CommandableVehiclesResponse(CommandableVehiclesResponse&& from) noexcept
    : CommandableVehiclesResponse() {
    *this = ::std::move(from);
  }

  inline CommandableVehiclesResponse& operator=(const CommandableVehiclesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandableVehiclesResponse& operator=(CommandableVehiclesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandableVehiclesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandableVehiclesResponse* internal_default_instance() {
    return reinterpret_cast<const CommandableVehiclesResponse*>(
               &_CommandableVehiclesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CommandableVehiclesResponse& a, CommandableVehiclesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandableVehiclesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandableVehiclesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandableVehiclesResponse* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandableVehiclesResponse>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const CommandableVehiclesResponse& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const CommandableVehiclesResponse& from) {
    CommandableVehiclesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandableVehiclesResponse* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMovement.CommandableVehiclesResponse";
  }
  protected:
  explicit CommandableVehiclesResponse(::google::protobuf_tempo::Arena* arena);
  CommandableVehiclesResponse(::google::protobuf_tempo::Arena* arena, const CommandableVehiclesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleNameFieldNumber = 1,
  };
  // repeated string vehicle_name = 1;
  int vehicle_name_size() const;
  private:
  int _internal_vehicle_name_size() const;

  public:
  void clear_vehicle_name() ;
  const std::string& vehicle_name(int index) const;
  std::string* mutable_vehicle_name(int index);
  void set_vehicle_name(int index, const std::string& value);
  void set_vehicle_name(int index, std::string&& value);
  void set_vehicle_name(int index, const char* value);
  void set_vehicle_name(int index, const char* value, std::size_t size);
  void set_vehicle_name(int index, absl_tempo::string_view value);
  std::string* add_vehicle_name();
  void add_vehicle_name(const std::string& value);
  void add_vehicle_name(std::string&& value);
  void add_vehicle_name(const char* value);
  void add_vehicle_name(const char* value, std::size_t size);
  void add_vehicle_name(absl_tempo::string_view value);
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& vehicle_name() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* mutable_vehicle_name();

  private:
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& _internal_vehicle_name() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* _internal_mutable_vehicle_name();

  public:
  // @@protoc_insertion_point(class_scope:TempoMovement.CommandableVehiclesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      0, 1, 0,
      62, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMOVEMENT_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::RepeatedPtrField<std::string> vehicle_name_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMovement_2fMovementControlService_2eproto;
};// -------------------------------------------------------------------

class TEMPOMOVEMENT_API CommandablePawnsResponse final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMovement.CommandablePawnsResponse) */ {
 public:
  inline CommandablePawnsResponse() : CommandablePawnsResponse(nullptr) {}
  ~CommandablePawnsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandablePawnsResponse(::google::protobuf_tempo::internal::ConstantInitialized);

  inline CommandablePawnsResponse(const CommandablePawnsResponse& from)
      : CommandablePawnsResponse(nullptr, from) {}
  CommandablePawnsResponse(CommandablePawnsResponse&& from) noexcept
    : CommandablePawnsResponse() {
    *this = ::std::move(from);
  }

  inline CommandablePawnsResponse& operator=(const CommandablePawnsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandablePawnsResponse& operator=(CommandablePawnsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandablePawnsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandablePawnsResponse* internal_default_instance() {
    return reinterpret_cast<const CommandablePawnsResponse*>(
               &_CommandablePawnsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CommandablePawnsResponse& a, CommandablePawnsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandablePawnsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandablePawnsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandablePawnsResponse* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandablePawnsResponse>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const CommandablePawnsResponse& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const CommandablePawnsResponse& from) {
    CommandablePawnsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandablePawnsResponse* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMovement.CommandablePawnsResponse";
  }
  protected:
  explicit CommandablePawnsResponse(::google::protobuf_tempo::Arena* arena);
  CommandablePawnsResponse(::google::protobuf_tempo::Arena* arena, const CommandablePawnsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPawnNameFieldNumber = 1,
  };
  // repeated string pawn_name = 1;
  int pawn_name_size() const;
  private:
  int _internal_pawn_name_size() const;

  public:
  void clear_pawn_name() ;
  const std::string& pawn_name(int index) const;
  std::string* mutable_pawn_name(int index);
  void set_pawn_name(int index, const std::string& value);
  void set_pawn_name(int index, std::string&& value);
  void set_pawn_name(int index, const char* value);
  void set_pawn_name(int index, const char* value, std::size_t size);
  void set_pawn_name(int index, absl_tempo::string_view value);
  std::string* add_pawn_name();
  void add_pawn_name(const std::string& value);
  void add_pawn_name(std::string&& value);
  void add_pawn_name(const char* value);
  void add_pawn_name(const char* value, std::size_t size);
  void add_pawn_name(absl_tempo::string_view value);
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& pawn_name() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* mutable_pawn_name();

  private:
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& _internal_pawn_name() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* _internal_mutable_pawn_name();

  public:
  // @@protoc_insertion_point(class_scope:TempoMovement.CommandablePawnsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      0, 1, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMOVEMENT_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::RepeatedPtrField<std::string> pawn_name_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMovement_2fMovementControlService_2eproto;
};// -------------------------------------------------------------------

class TEMPOMOVEMENT_API PawnMoveToLocationRequest final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMovement.PawnMoveToLocationRequest) */ {
 public:
  inline PawnMoveToLocationRequest() : PawnMoveToLocationRequest(nullptr) {}
  ~PawnMoveToLocationRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PawnMoveToLocationRequest(::google::protobuf_tempo::internal::ConstantInitialized);

  inline PawnMoveToLocationRequest(const PawnMoveToLocationRequest& from)
      : PawnMoveToLocationRequest(nullptr, from) {}
  PawnMoveToLocationRequest(PawnMoveToLocationRequest&& from) noexcept
    : PawnMoveToLocationRequest() {
    *this = ::std::move(from);
  }

  inline PawnMoveToLocationRequest& operator=(const PawnMoveToLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PawnMoveToLocationRequest& operator=(PawnMoveToLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PawnMoveToLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PawnMoveToLocationRequest* internal_default_instance() {
    return reinterpret_cast<const PawnMoveToLocationRequest*>(
               &_PawnMoveToLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PawnMoveToLocationRequest& a, PawnMoveToLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PawnMoveToLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PawnMoveToLocationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PawnMoveToLocationRequest* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PawnMoveToLocationRequest>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const PawnMoveToLocationRequest& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const PawnMoveToLocationRequest& from) {
    PawnMoveToLocationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(PawnMoveToLocationRequest* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMovement.PawnMoveToLocationRequest";
  }
  protected:
  explicit PawnMoveToLocationRequest(::google::protobuf_tempo::Arena* arena);
  PawnMoveToLocationRequest(::google::protobuf_tempo::Arena* arena, const PawnMoveToLocationRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLocationFieldNumber = 2,
    kRelativeFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .TempoScripting.Vector location = 2;
  bool has_location() const;
  void clear_location() ;
  const ::TempoScripting::Vector& location() const;
  PROTOBUF_NODISCARD ::TempoScripting::Vector* release_location();
  ::TempoScripting::Vector* mutable_location();
  void set_allocated_location(::TempoScripting::Vector* value);
  void unsafe_arena_set_allocated_location(::TempoScripting::Vector* value);
  ::TempoScripting::Vector* unsafe_arena_release_location();

  private:
  const ::TempoScripting::Vector& _internal_location() const;
  ::TempoScripting::Vector* _internal_mutable_location();

  public:
  // bool relative = 3;
  void clear_relative() ;
  bool relative() const;
  void set_relative(bool value);

  private:
  bool _internal_relative() const;
  void _internal_set_relative(bool value);

  public:
  // @@protoc_insertion_point(class_scope:TempoMovement.PawnMoveToLocationRequest)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      2, 3, 1,
      52, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMOVEMENT_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    ::google::protobuf_tempo::internal::ArenaStringPtr name_;
    ::TempoScripting::Vector* location_;
    bool relative_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMovement_2fMovementControlService_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CommandableVehiclesResponse

// repeated string vehicle_name = 1;
inline int CommandableVehiclesResponse::_internal_vehicle_name_size() const {
  return _internal_vehicle_name().size();
}
inline int CommandableVehiclesResponse::vehicle_name_size() const {
  return _internal_vehicle_name_size();
}
inline void CommandableVehiclesResponse::clear_vehicle_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vehicle_name_.Clear();
}
inline std::string* CommandableVehiclesResponse::add_vehicle_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_vehicle_name()->Add();
  // @@protoc_insertion_point(field_add_mutable:TempoMovement.CommandableVehiclesResponse.vehicle_name)
  return _s;
}
inline const std::string& CommandableVehiclesResponse::vehicle_name(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMovement.CommandableVehiclesResponse.vehicle_name)
  return _internal_vehicle_name().Get(index);
}
inline std::string* CommandableVehiclesResponse::mutable_vehicle_name(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMovement.CommandableVehiclesResponse.vehicle_name)
  return _internal_mutable_vehicle_name()->Mutable(index);
}
inline void CommandableVehiclesResponse::set_vehicle_name(int index, const std::string& value) {
  _internal_mutable_vehicle_name()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TempoMovement.CommandableVehiclesResponse.vehicle_name)
}
inline void CommandableVehiclesResponse::set_vehicle_name(int index, std::string&& value) {
  _internal_mutable_vehicle_name()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TempoMovement.CommandableVehiclesResponse.vehicle_name)
}
inline void CommandableVehiclesResponse::set_vehicle_name(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_vehicle_name()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TempoMovement.CommandableVehiclesResponse.vehicle_name)
}
inline void CommandableVehiclesResponse::set_vehicle_name(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_vehicle_name()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TempoMovement.CommandableVehiclesResponse.vehicle_name)
}
inline void CommandableVehiclesResponse::set_vehicle_name(int index, absl_tempo::string_view value) {
  _internal_mutable_vehicle_name()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:TempoMovement.CommandableVehiclesResponse.vehicle_name)
}
inline void CommandableVehiclesResponse::add_vehicle_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicle_name()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:TempoMovement.CommandableVehiclesResponse.vehicle_name)
}
inline void CommandableVehiclesResponse::add_vehicle_name(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicle_name()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:TempoMovement.CommandableVehiclesResponse.vehicle_name)
}
inline void CommandableVehiclesResponse::add_vehicle_name(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicle_name()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TempoMovement.CommandableVehiclesResponse.vehicle_name)
}
inline void CommandableVehiclesResponse::add_vehicle_name(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicle_name()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TempoMovement.CommandableVehiclesResponse.vehicle_name)
}
inline void CommandableVehiclesResponse::add_vehicle_name(absl_tempo::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vehicle_name()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:TempoMovement.CommandableVehiclesResponse.vehicle_name)
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
CommandableVehiclesResponse::vehicle_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMovement.CommandableVehiclesResponse.vehicle_name)
  return _internal_vehicle_name();
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
CommandableVehiclesResponse::mutable_vehicle_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMovement.CommandableVehiclesResponse.vehicle_name)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vehicle_name();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
CommandableVehiclesResponse::_internal_vehicle_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicle_name_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
CommandableVehiclesResponse::_internal_mutable_vehicle_name() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vehicle_name_;
}

// -------------------------------------------------------------------

// VehicleCommandRequest

// string vehicle_name = 1;
inline void VehicleCommandRequest::clear_vehicle_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vehicle_name_.ClearToEmpty();
}
inline const std::string& VehicleCommandRequest::vehicle_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMovement.VehicleCommandRequest.vehicle_name)
  return _internal_vehicle_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleCommandRequest::set_vehicle_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vehicle_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:TempoMovement.VehicleCommandRequest.vehicle_name)
}
inline std::string* VehicleCommandRequest::mutable_vehicle_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_vehicle_name();
  // @@protoc_insertion_point(field_mutable:TempoMovement.VehicleCommandRequest.vehicle_name)
  return _s;
}
inline const std::string& VehicleCommandRequest::_internal_vehicle_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vehicle_name_.Get();
}
inline void VehicleCommandRequest::_internal_set_vehicle_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vehicle_name_.Set(value, GetArena());
}
inline std::string* VehicleCommandRequest::_internal_mutable_vehicle_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.vehicle_name_.Mutable( GetArena());
}
inline std::string* VehicleCommandRequest::release_vehicle_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TempoMovement.VehicleCommandRequest.vehicle_name)
  return _impl_.vehicle_name_.Release();
}
inline void VehicleCommandRequest::set_allocated_vehicle_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vehicle_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vehicle_name_.IsDefault()) {
          _impl_.vehicle_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TempoMovement.VehicleCommandRequest.vehicle_name)
}

// float acceleration = 2;
inline void VehicleCommandRequest::clear_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceleration_ = 0;
}
inline float VehicleCommandRequest::acceleration() const {
  // @@protoc_insertion_point(field_get:TempoMovement.VehicleCommandRequest.acceleration)
  return _internal_acceleration();
}
inline void VehicleCommandRequest::set_acceleration(float value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:TempoMovement.VehicleCommandRequest.acceleration)
}
inline float VehicleCommandRequest::_internal_acceleration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceleration_;
}
inline void VehicleCommandRequest::_internal_set_acceleration(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceleration_ = value;
}

// float steering = 3;
inline void VehicleCommandRequest::clear_steering() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.steering_ = 0;
}
inline float VehicleCommandRequest::steering() const {
  // @@protoc_insertion_point(field_get:TempoMovement.VehicleCommandRequest.steering)
  return _internal_steering();
}
inline void VehicleCommandRequest::set_steering(float value) {
  _internal_set_steering(value);
  // @@protoc_insertion_point(field_set:TempoMovement.VehicleCommandRequest.steering)
}
inline float VehicleCommandRequest::_internal_steering() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.steering_;
}
inline void VehicleCommandRequest::_internal_set_steering(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.steering_ = value;
}

// -------------------------------------------------------------------

// CommandablePawnsResponse

// repeated string pawn_name = 1;
inline int CommandablePawnsResponse::_internal_pawn_name_size() const {
  return _internal_pawn_name().size();
}
inline int CommandablePawnsResponse::pawn_name_size() const {
  return _internal_pawn_name_size();
}
inline void CommandablePawnsResponse::clear_pawn_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pawn_name_.Clear();
}
inline std::string* CommandablePawnsResponse::add_pawn_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_pawn_name()->Add();
  // @@protoc_insertion_point(field_add_mutable:TempoMovement.CommandablePawnsResponse.pawn_name)
  return _s;
}
inline const std::string& CommandablePawnsResponse::pawn_name(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMovement.CommandablePawnsResponse.pawn_name)
  return _internal_pawn_name().Get(index);
}
inline std::string* CommandablePawnsResponse::mutable_pawn_name(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMovement.CommandablePawnsResponse.pawn_name)
  return _internal_mutable_pawn_name()->Mutable(index);
}
inline void CommandablePawnsResponse::set_pawn_name(int index, const std::string& value) {
  _internal_mutable_pawn_name()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TempoMovement.CommandablePawnsResponse.pawn_name)
}
inline void CommandablePawnsResponse::set_pawn_name(int index, std::string&& value) {
  _internal_mutable_pawn_name()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TempoMovement.CommandablePawnsResponse.pawn_name)
}
inline void CommandablePawnsResponse::set_pawn_name(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_pawn_name()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TempoMovement.CommandablePawnsResponse.pawn_name)
}
inline void CommandablePawnsResponse::set_pawn_name(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_pawn_name()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TempoMovement.CommandablePawnsResponse.pawn_name)
}
inline void CommandablePawnsResponse::set_pawn_name(int index, absl_tempo::string_view value) {
  _internal_mutable_pawn_name()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:TempoMovement.CommandablePawnsResponse.pawn_name)
}
inline void CommandablePawnsResponse::add_pawn_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pawn_name()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:TempoMovement.CommandablePawnsResponse.pawn_name)
}
inline void CommandablePawnsResponse::add_pawn_name(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pawn_name()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:TempoMovement.CommandablePawnsResponse.pawn_name)
}
inline void CommandablePawnsResponse::add_pawn_name(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pawn_name()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TempoMovement.CommandablePawnsResponse.pawn_name)
}
inline void CommandablePawnsResponse::add_pawn_name(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pawn_name()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TempoMovement.CommandablePawnsResponse.pawn_name)
}
inline void CommandablePawnsResponse::add_pawn_name(absl_tempo::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pawn_name()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:TempoMovement.CommandablePawnsResponse.pawn_name)
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
CommandablePawnsResponse::pawn_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMovement.CommandablePawnsResponse.pawn_name)
  return _internal_pawn_name();
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
CommandablePawnsResponse::mutable_pawn_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMovement.CommandablePawnsResponse.pawn_name)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_pawn_name();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
CommandablePawnsResponse::_internal_pawn_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pawn_name_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
CommandablePawnsResponse::_internal_mutable_pawn_name() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.pawn_name_;
}

// -------------------------------------------------------------------

// PawnMoveToLocationRequest

// string name = 1;
inline void PawnMoveToLocationRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PawnMoveToLocationRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMovement.PawnMoveToLocationRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PawnMoveToLocationRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:TempoMovement.PawnMoveToLocationRequest.name)
}
inline std::string* PawnMoveToLocationRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:TempoMovement.PawnMoveToLocationRequest.name)
  return _s;
}
inline const std::string& PawnMoveToLocationRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void PawnMoveToLocationRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PawnMoveToLocationRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PawnMoveToLocationRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TempoMovement.PawnMoveToLocationRequest.name)
  return _impl_.name_.Release();
}
inline void PawnMoveToLocationRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TempoMovement.PawnMoveToLocationRequest.name)
}

// .TempoScripting.Vector location = 2;
inline bool PawnMoveToLocationRequest::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline const ::TempoScripting::Vector& PawnMoveToLocationRequest::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TempoScripting::Vector* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::TempoScripting::Vector&>(::TempoScripting::_Vector_default_instance_);
}
inline const ::TempoScripting::Vector& PawnMoveToLocationRequest::location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMovement.PawnMoveToLocationRequest.location)
  return _internal_location();
}
inline void PawnMoveToLocationRequest::unsafe_arena_set_allocated_location(::TempoScripting::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::TempoScripting::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TempoMovement.PawnMoveToLocationRequest.location)
}
inline ::TempoScripting::Vector* PawnMoveToLocationRequest::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TempoScripting::Vector* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(released);
  released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TempoScripting::Vector* PawnMoveToLocationRequest::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TempoMovement.PawnMoveToLocationRequest.location)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TempoScripting::Vector* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::TempoScripting::Vector* PawnMoveToLocationRequest::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::TempoScripting::Vector>(GetArena());
    _impl_.location_ = reinterpret_cast<::TempoScripting::Vector*>(p);
  }
  return _impl_.location_;
}
inline ::TempoScripting::Vector* PawnMoveToLocationRequest::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TempoScripting::Vector* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:TempoMovement.PawnMoveToLocationRequest.location)
  return _msg;
}
inline void PawnMoveToLocationRequest::set_allocated_location(::TempoScripting::Vector* value) {
  ::google::protobuf_tempo::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf_tempo::Arena* submessage_arena = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_tempo::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.location_ = reinterpret_cast<::TempoScripting::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:TempoMovement.PawnMoveToLocationRequest.location)
}

// bool relative = 3;
inline void PawnMoveToLocationRequest::clear_relative() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relative_ = false;
}
inline bool PawnMoveToLocationRequest::relative() const {
  // @@protoc_insertion_point(field_get:TempoMovement.PawnMoveToLocationRequest.relative)
  return _internal_relative();
}
inline void PawnMoveToLocationRequest::set_relative(bool value) {
  _internal_set_relative(value);
  // @@protoc_insertion_point(field_set:TempoMovement.PawnMoveToLocationRequest.relative)
}
inline bool PawnMoveToLocationRequest::_internal_relative() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relative_;
}
inline void PawnMoveToLocationRequest::_internal_set_relative(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.relative_ = value;
}

// -------------------------------------------------------------------

// PawnMoveToLocationResponse

// .TempoMovement.MoveToResult result = 1;
inline void PawnMoveToLocationResponse::clear_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.result_ = 0;
}
inline ::TempoMovement::MoveToResult PawnMoveToLocationResponse::result() const {
  // @@protoc_insertion_point(field_get:TempoMovement.PawnMoveToLocationResponse.result)
  return _internal_result();
}
inline void PawnMoveToLocationResponse::set_result(::TempoMovement::MoveToResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:TempoMovement.PawnMoveToLocationResponse.result)
}
inline ::TempoMovement::MoveToResult PawnMoveToLocationResponse::_internal_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::TempoMovement::MoveToResult>(_impl_.result_);
}
inline void PawnMoveToLocationResponse::_internal_set_result(::TempoMovement::MoveToResult value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace TempoMovement


namespace google {
namespace protobuf_tempo {

template <>
struct is_proto_enum<::TempoMovement::MoveToResult> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::TempoMovement::MoveToResult>() {
  return ::TempoMovement::MoveToResult_descriptor();
}

}  // namespace protobuf_tempo
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_TempoMovement_2fMovementControlService_2eproto_2epb_2eh
