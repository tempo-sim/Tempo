diff --git Source/PCG/Private/MeshSelectors/PCGMeshSelectorByAttribute.cpp Source/PCG/Private/MeshSelectors/PCGMeshSelectorByAttribute.cpp
--- Source/PCG/Private/MeshSelectors/PCGMeshSelectorByAttribute.cpp
+++ Source/PCG/Private/MeshSelectors/PCGMeshSelectorByAttribute.cpp
@@ -223,8 +223,11 @@ void UPCGMeshSelectorByAttribute::SelectMeshInstances(
 				FPCGObjectOverrides Overrides(&Descriptor);
 				Overrides.Initialize(PropertyOverrides, &Descriptor, InPointData, &Context);

 				// Since they are already partitioned and identical, we can just use the value on the first point
 				check(!Context.AttributeOverridePartition[I].IsEmpty());
 				int32 AnyPointIndexOnThisPartition = Context.AttributeOverridePartition[I][0];
 				Overrides.Apply(AnyPointIndexOnThisPartition);
+				// Some overrides (e.g. CollisionProfileName) only update the name; FixupData rebuilds the response container so collision enables correctly.
+				Descriptor.BodyInstance.FixupData(Context.GetTargetActor(nullptr));
 			}

 			// Given partitioning is expensive, check if we're out of time for this frame
diff --git Source/PCG/Private/Elements/PCGSpawnSplineMesh.cpp Source/PCG/Private/Elements/PCGSpawnSplineMesh.cpp
--- Source/PCG/Private/Elements/PCGSpawnSplineMesh.cpp
+++ Source/PCG/Private/Elements/PCGSpawnSplineMesh.cpp
@@ -185,6 +185,8 @@ bool FPCGSpawnSplineMeshElement::ExecuteInternal(FPCGContext* InContext) const
 		if (IterState.DescriptionOverrides.IsValid() && !IterState.DescriptionOverrides.Apply(IterState.ElementIndex))
 		{
 			PCGLog::LogWarningOnGraph(FText::Format(LOCTEXT("FailOverrideDescriptor", "Failed to override descriptor for input {0} element {1}"), IterIndex, IterState.ElementIndex));
 		}
+		// Ensure override of CollisionProfileName rebuilds the response container so collision queries behave as expected.
+		IterState.SMCBuilderParams.Descriptor.BodyInstance.FixupData(Context->GetTargetActor(nullptr));

 		UStaticMesh* StaticMesh = IterState.SMCBuilderParams.Descriptor.StaticMesh.Get();
