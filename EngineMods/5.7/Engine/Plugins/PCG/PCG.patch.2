diff --git Source/PCG/Private/Data/PCGLandscapeData.cpp Source/PCG/Private/Data/PCGLandscapeData.cpp
--- Source/PCG/Private/Data/PCGLandscapeData.cpp
+++ Source/PCG/Private/Data/PCGLandscapeData.cpp
@@ -362,29 +362,33 @@
 	// Not needed anymore
 	LandscapeCacheEntry.Reset();
 
-	ULandscapeHeightfieldCollisionComponent* LandscapeCollisionComponent = LandscapeInfo->XYtoCollisionComponentMap.FindRef(ComponentMapKey);
-
-	if (DataProps.bGetActorReference && OutMetadata && LandscapeCollisionComponent)
-	{
-		if (FPCGMetadataAttribute<FSoftObjectPath>* ActorReferenceAttribute = OutMetadata->FindOrCreateAttribute<FSoftObjectPath>(PCGPointDataConstants::ActorReferenceAttribute))
-		{
-			// Landscape code seems to indicate the XYtoComponentMap can be sometimes invalid, so rely on the collision map instead
-			OutMetadata->InitializeOnSet(OutPoint.MetadataEntry);
-			ActorReferenceAttribute->SetValue(OutPoint.MetadataEntry, FSoftObjectPath(LandscapeCollisionComponent->GetOwner()));
-		}
-	}
-
-	if (DataProps.bGetPhysicalMaterial && OutMetadata && LandscapeCollisionComponent)
-	{
-		if (FPCGMetadataAttribute<FSoftObjectPath>* PhysicalMaterialAttribute = OutMetadata->FindOrCreateAttribute<FSoftObjectPath>(PCGWorldQueryConstants::PhysicalMaterialReferenceAttribute))
-		{
-			if(UPhysicalMaterial* PhysicalMaterial = LandscapeCollisionComponent->GetPhysicalMaterial(static_cast<float>(ComponentLocalPoint.X), static_cast<float>(ComponentLocalPoint.Y), EHeightfieldSource::Complex))
-			{
-				OutMetadata->InitializeOnSet(OutPoint.MetadataEntry);
-				PhysicalMaterialAttribute->SetValue(OutPoint.MetadataEntry, FSoftObjectPath(PhysicalMaterial));
-			}
-		}
-	}
+	// It's not safe to interact with LandscapeInfo->XYtoCollisionComponentMap from a background thread
+	if (IsInGameThread())
+	{
+		ULandscapeHeightfieldCollisionComponent* LandscapeCollisionComponent = LandscapeInfo->XYtoCollisionComponentMap.FindRef(ComponentMapKey);
+	
+		if (DataProps.bGetActorReference && OutMetadata && LandscapeCollisionComponent)
+		{
+			if (FPCGMetadataAttribute<FSoftObjectPath>* ActorReferenceAttribute = OutMetadata->FindOrCreateAttribute<FSoftObjectPath>(PCGPointDataConstants::ActorReferenceAttribute))
+			{
+				// Landscape code seems to indicate the XYtoComponentMap can be sometimes invalid, so rely on the collision map instead
+				OutMetadata->InitializeOnSet(OutPoint.MetadataEntry);
+				ActorReferenceAttribute->SetValue(OutPoint.MetadataEntry, FSoftObjectPath(LandscapeCollisionComponent->GetOwner()));
+			}
+		}
+	
+		if (DataProps.bGetPhysicalMaterial && OutMetadata && LandscapeCollisionComponent)
+		{
+			if (FPCGMetadataAttribute<FSoftObjectPath>* PhysicalMaterialAttribute = OutMetadata->FindOrCreateAttribute<FSoftObjectPath>(PCGWorldQueryConstants::PhysicalMaterialReferenceAttribute))
+			{
+				if(UPhysicalMaterial* PhysicalMaterial = LandscapeCollisionComponent->GetPhysicalMaterial(static_cast<float>(ComponentLocalPoint.X), static_cast<float>(ComponentLocalPoint.Y), EHeightfieldSource::Complex))
+				{
+					OutMetadata->InitializeOnSet(OutPoint.MetadataEntry);
+					PhysicalMaterialAttribute->SetValue(OutPoint.MetadataEntry, FSoftObjectPath(PhysicalMaterial));
+				}
+			}
+		}
+	}
 
	if (DataProps.bGetComponentCoordinates && OutMetadata)
 	{
