// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TempoScripting/Geometry.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_TempoScripting_2fGeometry_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_TempoScripting_2fGeometry_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_TempoScripting_2fGeometry_2eproto TEMPOSCRIPTING_API

namespace google {
namespace protobuf_tempo {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf_tempo
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TEMPOSCRIPTING_API TableStruct_TempoScripting_2fGeometry_2eproto {
  static const ::uint32_t offsets[];
};
TEMPOSCRIPTING_API extern const ::google::protobuf_tempo::internal::DescriptorTable
    descriptor_table_TempoScripting_2fGeometry_2eproto;
namespace TempoScripting {
class Box;
struct BoxDefaultTypeInternal;
TEMPOSCRIPTING_API extern BoxDefaultTypeInternal _Box_default_instance_;
class Rotation;
struct RotationDefaultTypeInternal;
TEMPOSCRIPTING_API extern RotationDefaultTypeInternal _Rotation_default_instance_;
class Transform;
struct TransformDefaultTypeInternal;
TEMPOSCRIPTING_API extern TransformDefaultTypeInternal _Transform_default_instance_;
class Vector;
struct VectorDefaultTypeInternal;
TEMPOSCRIPTING_API extern VectorDefaultTypeInternal _Vector_default_instance_;
class Vector2D;
struct Vector2DDefaultTypeInternal;
TEMPOSCRIPTING_API extern Vector2DDefaultTypeInternal _Vector2D_default_instance_;
}  // namespace TempoScripting
namespace google {
namespace protobuf_tempo {
}  // namespace protobuf_tempo
}  // namespace google

namespace TempoScripting {

// ===================================================================


// -------------------------------------------------------------------

class TEMPOSCRIPTING_API Vector2D final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoScripting.Vector2D) */ {
 public:
  inline Vector2D() : Vector2D(nullptr) {}
  ~Vector2D() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vector2D(::google::protobuf_tempo::internal::ConstantInitialized);

  inline Vector2D(const Vector2D& from)
      : Vector2D(nullptr, from) {}
  Vector2D(Vector2D&& from) noexcept
    : Vector2D() {
    *this = ::std::move(from);
  }

  inline Vector2D& operator=(const Vector2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2D& operator=(Vector2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2D* internal_default_instance() {
    return reinterpret_cast<const Vector2D*>(
               &_Vector2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector2D& a, Vector2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2D* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector2D* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector2D>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const Vector2D& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const Vector2D& from) {
    Vector2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector2D* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoScripting.Vector2D";
  }
  protected:
  explicit Vector2D(::google::protobuf_tempo::Arena* arena);
  Vector2D(::google::protobuf_tempo::Arena* arena, const Vector2D& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // double x = 1;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // @@protoc_insertion_point(class_scope:TempoScripting.Vector2D)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOSCRIPTING_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    double x_;
    double y_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoScripting_2fGeometry_2eproto;
};// -------------------------------------------------------------------

class TEMPOSCRIPTING_API Vector final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoScripting.Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vector(::google::protobuf_tempo::internal::ConstantInitialized);

  inline Vector(const Vector& from)
      : Vector(nullptr, from) {}
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const Vector& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const Vector& from) {
    Vector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoScripting.Vector";
  }
  protected:
  explicit Vector(::google::protobuf_tempo::Arena* arena);
  Vector(::google::protobuf_tempo::Arena* arena, const Vector& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:TempoScripting.Vector)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOSCRIPTING_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    double x_;
    double y_;
    double z_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoScripting_2fGeometry_2eproto;
};// -------------------------------------------------------------------

class TEMPOSCRIPTING_API Rotation final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoScripting.Rotation) */ {
 public:
  inline Rotation() : Rotation(nullptr) {}
  ~Rotation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rotation(::google::protobuf_tempo::internal::ConstantInitialized);

  inline Rotation(const Rotation& from)
      : Rotation(nullptr, from) {}
  Rotation(Rotation&& from) noexcept
    : Rotation() {
    *this = ::std::move(from);
  }

  inline Rotation& operator=(const Rotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rotation& operator=(Rotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rotation* internal_default_instance() {
    return reinterpret_cast<const Rotation*>(
               &_Rotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Rotation& a, Rotation& b) {
    a.Swap(&b);
  }
  inline void Swap(Rotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rotation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rotation* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rotation>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const Rotation& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const Rotation& from) {
    Rotation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rotation* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoScripting.Rotation";
  }
  protected:
  explicit Rotation(::google::protobuf_tempo::Arena* arena);
  Rotation(::google::protobuf_tempo::Arena* arena, const Rotation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kPFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // double r = 1;
  void clear_r() ;
  double r() const;
  void set_r(double value);

  private:
  double _internal_r() const;
  void _internal_set_r(double value);

  public:
  // double p = 2;
  void clear_p() ;
  double p() const;
  void set_p(double value);

  private:
  double _internal_p() const;
  void _internal_set_p(double value);

  public:
  // double y = 3;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // @@protoc_insertion_point(class_scope:TempoScripting.Rotation)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOSCRIPTING_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    double r_;
    double p_;
    double y_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoScripting_2fGeometry_2eproto;
};// -------------------------------------------------------------------

class TEMPOSCRIPTING_API Transform final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoScripting.Transform) */ {
 public:
  inline Transform() : Transform(nullptr) {}
  ~Transform() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Transform(::google::protobuf_tempo::internal::ConstantInitialized);

  inline Transform(const Transform& from)
      : Transform(nullptr, from) {}
  Transform(Transform&& from) noexcept
    : Transform() {
    *this = ::std::move(from);
  }

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transform& operator=(Transform&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transform& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Transform& a, Transform& b) {
    a.Swap(&b);
  }
  inline void Swap(Transform* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transform* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transform* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transform>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const Transform& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const Transform& from) {
    Transform::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(Transform* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoScripting.Transform";
  }
  protected:
  explicit Transform(::google::protobuf_tempo::Arena* arena);
  Transform(::google::protobuf_tempo::Arena* arena, const Transform& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  // .TempoScripting.Vector location = 1;
  bool has_location() const;
  void clear_location() ;
  const ::TempoScripting::Vector& location() const;
  PROTOBUF_NODISCARD ::TempoScripting::Vector* release_location();
  ::TempoScripting::Vector* mutable_location();
  void set_allocated_location(::TempoScripting::Vector* value);
  void unsafe_arena_set_allocated_location(::TempoScripting::Vector* value);
  ::TempoScripting::Vector* unsafe_arena_release_location();

  private:
  const ::TempoScripting::Vector& _internal_location() const;
  ::TempoScripting::Vector* _internal_mutable_location();

  public:
  // .TempoScripting.Rotation rotation = 2;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::TempoScripting::Rotation& rotation() const;
  PROTOBUF_NODISCARD ::TempoScripting::Rotation* release_rotation();
  ::TempoScripting::Rotation* mutable_rotation();
  void set_allocated_rotation(::TempoScripting::Rotation* value);
  void unsafe_arena_set_allocated_rotation(::TempoScripting::Rotation* value);
  ::TempoScripting::Rotation* unsafe_arena_release_rotation();

  private:
  const ::TempoScripting::Rotation& _internal_rotation() const;
  ::TempoScripting::Rotation* _internal_mutable_rotation();

  public:
  // @@protoc_insertion_point(class_scope:TempoScripting.Transform)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOSCRIPTING_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    ::TempoScripting::Vector* location_;
    ::TempoScripting::Rotation* rotation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoScripting_2fGeometry_2eproto;
};// -------------------------------------------------------------------

class TEMPOSCRIPTING_API Box final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoScripting.Box) */ {
 public:
  inline Box() : Box(nullptr) {}
  ~Box() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Box(::google::protobuf_tempo::internal::ConstantInitialized);

  inline Box(const Box& from)
      : Box(nullptr, from) {}
  Box(Box&& from) noexcept
    : Box() {
    *this = ::std::move(from);
  }

  inline Box& operator=(const Box& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box& operator=(Box&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Box& default_instance() {
    return *internal_default_instance();
  }
  static inline const Box* internal_default_instance() {
    return reinterpret_cast<const Box*>(
               &_Box_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Box& a, Box& b) {
    a.Swap(&b);
  }
  inline void Swap(Box* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Box* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Box>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const Box& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const Box& from) {
    Box::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(Box* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoScripting.Box";
  }
  protected:
  explicit Box(::google::protobuf_tempo::Arena* arena);
  Box(::google::protobuf_tempo::Arena* arena, const Box& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // .TempoScripting.Vector Min = 1;
  bool has_min() const;
  void clear_min() ;
  const ::TempoScripting::Vector& min() const;
  PROTOBUF_NODISCARD ::TempoScripting::Vector* release_min();
  ::TempoScripting::Vector* mutable_min();
  void set_allocated_min(::TempoScripting::Vector* value);
  void unsafe_arena_set_allocated_min(::TempoScripting::Vector* value);
  ::TempoScripting::Vector* unsafe_arena_release_min();

  private:
  const ::TempoScripting::Vector& _internal_min() const;
  ::TempoScripting::Vector* _internal_mutable_min();

  public:
  // .TempoScripting.Vector Max = 2;
  bool has_max() const;
  void clear_max() ;
  const ::TempoScripting::Vector& max() const;
  PROTOBUF_NODISCARD ::TempoScripting::Vector* release_max();
  ::TempoScripting::Vector* mutable_max();
  void set_allocated_max(::TempoScripting::Vector* value);
  void unsafe_arena_set_allocated_max(::TempoScripting::Vector* value);
  ::TempoScripting::Vector* unsafe_arena_release_max();

  private:
  const ::TempoScripting::Vector& _internal_max() const;
  ::TempoScripting::Vector* _internal_mutable_max();

  public:
  // @@protoc_insertion_point(class_scope:TempoScripting.Box)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOSCRIPTING_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    ::TempoScripting::Vector* min_;
    ::TempoScripting::Vector* max_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoScripting_2fGeometry_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector2D

// double x = 1;
inline void Vector2D::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Vector2D::x() const {
  // @@protoc_insertion_point(field_get:TempoScripting.Vector2D.x)
  return _internal_x();
}
inline void Vector2D::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TempoScripting.Vector2D.x)
}
inline double Vector2D::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Vector2D::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 2;
inline void Vector2D::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Vector2D::y() const {
  // @@protoc_insertion_point(field_get:TempoScripting.Vector2D.y)
  return _internal_y();
}
inline void Vector2D::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TempoScripting.Vector2D.y)
}
inline double Vector2D::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Vector2D::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Vector

// double x = 1;
inline void Vector::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Vector::x() const {
  // @@protoc_insertion_point(field_get:TempoScripting.Vector.x)
  return _internal_x();
}
inline void Vector::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TempoScripting.Vector.x)
}
inline double Vector::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Vector::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 2;
inline void Vector::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Vector::y() const {
  // @@protoc_insertion_point(field_get:TempoScripting.Vector.y)
  return _internal_y();
}
inline void Vector::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TempoScripting.Vector.y)
}
inline double Vector::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Vector::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// double z = 3;
inline void Vector::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline double Vector::z() const {
  // @@protoc_insertion_point(field_get:TempoScripting.Vector.z)
  return _internal_z();
}
inline void Vector::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:TempoScripting.Vector.z)
}
inline double Vector::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Vector::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Rotation

// double r = 1;
inline void Rotation::clear_r() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.r_ = 0;
}
inline double Rotation::r() const {
  // @@protoc_insertion_point(field_get:TempoScripting.Rotation.r)
  return _internal_r();
}
inline void Rotation::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:TempoScripting.Rotation.r)
}
inline double Rotation::_internal_r() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.r_;
}
inline void Rotation::_internal_set_r(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.r_ = value;
}

// double p = 2;
inline void Rotation::clear_p() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.p_ = 0;
}
inline double Rotation::p() const {
  // @@protoc_insertion_point(field_get:TempoScripting.Rotation.p)
  return _internal_p();
}
inline void Rotation::set_p(double value) {
  _internal_set_p(value);
  // @@protoc_insertion_point(field_set:TempoScripting.Rotation.p)
}
inline double Rotation::_internal_p() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.p_;
}
inline void Rotation::_internal_set_p(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.p_ = value;
}

// double y = 3;
inline void Rotation::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Rotation::y() const {
  // @@protoc_insertion_point(field_get:TempoScripting.Rotation.y)
  return _internal_y();
}
inline void Rotation::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TempoScripting.Rotation.y)
}
inline double Rotation::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Rotation::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Transform

// .TempoScripting.Vector location = 1;
inline bool Transform::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline void Transform::clear_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TempoScripting::Vector& Transform::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TempoScripting::Vector* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::TempoScripting::Vector&>(::TempoScripting::_Vector_default_instance_);
}
inline const ::TempoScripting::Vector& Transform::location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoScripting.Transform.location)
  return _internal_location();
}
inline void Transform::unsafe_arena_set_allocated_location(::TempoScripting::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::TempoScripting::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TempoScripting.Transform.location)
}
inline ::TempoScripting::Vector* Transform::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TempoScripting::Vector* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(released);
  released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TempoScripting::Vector* Transform::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TempoScripting.Transform.location)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TempoScripting::Vector* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::TempoScripting::Vector* Transform::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::TempoScripting::Vector>(GetArena());
    _impl_.location_ = reinterpret_cast<::TempoScripting::Vector*>(p);
  }
  return _impl_.location_;
}
inline ::TempoScripting::Vector* Transform::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TempoScripting::Vector* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:TempoScripting.Transform.location)
  return _msg;
}
inline void Transform::set_allocated_location(::TempoScripting::Vector* value) {
  ::google::protobuf_tempo::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::TempoScripting::Vector*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf_tempo::Arena* submessage_arena = reinterpret_cast<::TempoScripting::Vector*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_tempo::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.location_ = reinterpret_cast<::TempoScripting::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:TempoScripting.Transform.location)
}

// .TempoScripting.Rotation rotation = 2;
inline bool Transform::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void Transform::clear_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TempoScripting::Rotation& Transform::_internal_rotation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TempoScripting::Rotation* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::TempoScripting::Rotation&>(::TempoScripting::_Rotation_default_instance_);
}
inline const ::TempoScripting::Rotation& Transform::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoScripting.Transform.rotation)
  return _internal_rotation();
}
inline void Transform::unsafe_arena_set_allocated_rotation(::TempoScripting::Rotation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::TempoScripting::Rotation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TempoScripting.Transform.rotation)
}
inline ::TempoScripting::Rotation* Transform::release_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TempoScripting::Rotation* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(released);
  released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TempoScripting::Rotation* Transform::unsafe_arena_release_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TempoScripting.Transform.rotation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TempoScripting::Rotation* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::TempoScripting::Rotation* Transform::_internal_mutable_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TempoScripting::Rotation>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::TempoScripting::Rotation*>(p);
  }
  return _impl_.rotation_;
}
inline ::TempoScripting::Rotation* Transform::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TempoScripting::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:TempoScripting.Transform.rotation)
  return _msg;
}
inline void Transform::set_allocated_rotation(::TempoScripting::Rotation* value) {
  ::google::protobuf_tempo::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::TempoScripting::Rotation*>(_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf_tempo::Arena* submessage_arena = reinterpret_cast<::TempoScripting::Rotation*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_tempo::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rotation_ = reinterpret_cast<::TempoScripting::Rotation*>(value);
  // @@protoc_insertion_point(field_set_allocated:TempoScripting.Transform.rotation)
}

// -------------------------------------------------------------------

// Box

// .TempoScripting.Vector Min = 1;
inline bool Box::has_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_ != nullptr);
  return value;
}
inline void Box::clear_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.min_ != nullptr) _impl_.min_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TempoScripting::Vector& Box::_internal_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TempoScripting::Vector* p = _impl_.min_;
  return p != nullptr ? *p : reinterpret_cast<const ::TempoScripting::Vector&>(::TempoScripting::_Vector_default_instance_);
}
inline const ::TempoScripting::Vector& Box::min() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoScripting.Box.Min)
  return _internal_min();
}
inline void Box::unsafe_arena_set_allocated_min(::TempoScripting::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.min_);
  }
  _impl_.min_ = reinterpret_cast<::TempoScripting::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TempoScripting.Box.Min)
}
inline ::TempoScripting::Vector* Box::release_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TempoScripting::Vector* released = _impl_.min_;
  _impl_.min_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(released);
  released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TempoScripting::Vector* Box::unsafe_arena_release_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TempoScripting.Box.Min)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TempoScripting::Vector* temp = _impl_.min_;
  _impl_.min_ = nullptr;
  return temp;
}
inline ::TempoScripting::Vector* Box::_internal_mutable_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.min_ == nullptr) {
    auto* p = CreateMaybeMessage<::TempoScripting::Vector>(GetArena());
    _impl_.min_ = reinterpret_cast<::TempoScripting::Vector*>(p);
  }
  return _impl_.min_;
}
inline ::TempoScripting::Vector* Box::mutable_min() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TempoScripting::Vector* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:TempoScripting.Box.Min)
  return _msg;
}
inline void Box::set_allocated_min(::TempoScripting::Vector* value) {
  ::google::protobuf_tempo::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::TempoScripting::Vector*>(_impl_.min_);
  }

  if (value != nullptr) {
    ::google::protobuf_tempo::Arena* submessage_arena = reinterpret_cast<::TempoScripting::Vector*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_tempo::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.min_ = reinterpret_cast<::TempoScripting::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:TempoScripting.Box.Min)
}

// .TempoScripting.Vector Max = 2;
inline bool Box::has_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_ != nullptr);
  return value;
}
inline void Box::clear_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.max_ != nullptr) _impl_.max_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TempoScripting::Vector& Box::_internal_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TempoScripting::Vector* p = _impl_.max_;
  return p != nullptr ? *p : reinterpret_cast<const ::TempoScripting::Vector&>(::TempoScripting::_Vector_default_instance_);
}
inline const ::TempoScripting::Vector& Box::max() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoScripting.Box.Max)
  return _internal_max();
}
inline void Box::unsafe_arena_set_allocated_max(::TempoScripting::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.max_);
  }
  _impl_.max_ = reinterpret_cast<::TempoScripting::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TempoScripting.Box.Max)
}
inline ::TempoScripting::Vector* Box::release_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TempoScripting::Vector* released = _impl_.max_;
  _impl_.max_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(released);
  released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TempoScripting::Vector* Box::unsafe_arena_release_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TempoScripting.Box.Max)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TempoScripting::Vector* temp = _impl_.max_;
  _impl_.max_ = nullptr;
  return temp;
}
inline ::TempoScripting::Vector* Box::_internal_mutable_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.max_ == nullptr) {
    auto* p = CreateMaybeMessage<::TempoScripting::Vector>(GetArena());
    _impl_.max_ = reinterpret_cast<::TempoScripting::Vector*>(p);
  }
  return _impl_.max_;
}
inline ::TempoScripting::Vector* Box::mutable_max() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TempoScripting::Vector* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:TempoScripting.Box.Max)
  return _msg;
}
inline void Box::set_allocated_max(::TempoScripting::Vector* value) {
  ::google::protobuf_tempo::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::TempoScripting::Vector*>(_impl_.max_);
  }

  if (value != nullptr) {
    ::google::protobuf_tempo::Arena* submessage_arena = reinterpret_cast<::TempoScripting::Vector*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_tempo::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.max_ = reinterpret_cast<::TempoScripting::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:TempoScripting.Box.Max)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace TempoScripting


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_TempoScripting_2fGeometry_2eproto_2epb_2eh
