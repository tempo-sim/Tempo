// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TempoMapQuery/MapQueries.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_TempoMapQuery_2fMapQueries_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_TempoMapQuery_2fMapQueries_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "TempoScripting/Geometry.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_TempoMapQuery_2fMapQueries_2eproto TEMPOMAPQUERY_API

namespace google {
namespace protobuf_tempo {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf_tempo
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TEMPOMAPQUERY_API TableStruct_TempoMapQuery_2fMapQueries_2eproto {
  static const ::uint32_t offsets[];
};
TEMPOMAPQUERY_API extern const ::google::protobuf_tempo::internal::DescriptorTable
    descriptor_table_TempoMapQuery_2fMapQueries_2eproto;
namespace TempoMapQuery {
class LaneAccessibilityRequest;
struct LaneAccessibilityRequestDefaultTypeInternal;
TEMPOMAPQUERY_API extern LaneAccessibilityRequestDefaultTypeInternal _LaneAccessibilityRequest_default_instance_;
class LaneAccessibilityResponse;
struct LaneAccessibilityResponseDefaultTypeInternal;
TEMPOMAPQUERY_API extern LaneAccessibilityResponseDefaultTypeInternal _LaneAccessibilityResponse_default_instance_;
class LaneConnection;
struct LaneConnectionDefaultTypeInternal;
TEMPOMAPQUERY_API extern LaneConnectionDefaultTypeInternal _LaneConnection_default_instance_;
class LaneData;
struct LaneDataDefaultTypeInternal;
TEMPOMAPQUERY_API extern LaneDataDefaultTypeInternal _LaneData_default_instance_;
class LaneDataRequest;
struct LaneDataRequestDefaultTypeInternal;
TEMPOMAPQUERY_API extern LaneDataRequestDefaultTypeInternal _LaneDataRequest_default_instance_;
class LaneDataResponse;
struct LaneDataResponseDefaultTypeInternal;
TEMPOMAPQUERY_API extern LaneDataResponseDefaultTypeInternal _LaneDataResponse_default_instance_;
class TagFilter;
struct TagFilterDefaultTypeInternal;
TEMPOMAPQUERY_API extern TagFilterDefaultTypeInternal _TagFilter_default_instance_;
class ZoneConnection;
struct ZoneConnectionDefaultTypeInternal;
TEMPOMAPQUERY_API extern ZoneConnectionDefaultTypeInternal _ZoneConnection_default_instance_;
class ZoneData;
struct ZoneDataDefaultTypeInternal;
TEMPOMAPQUERY_API extern ZoneDataDefaultTypeInternal _ZoneData_default_instance_;
class ZoneDataRequest;
struct ZoneDataRequestDefaultTypeInternal;
TEMPOMAPQUERY_API extern ZoneDataRequestDefaultTypeInternal _ZoneDataRequest_default_instance_;
class ZoneDataResponse;
struct ZoneDataResponseDefaultTypeInternal;
TEMPOMAPQUERY_API extern ZoneDataResponseDefaultTypeInternal _ZoneDataResponse_default_instance_;
}  // namespace TempoMapQuery
namespace google {
namespace protobuf_tempo {
}  // namespace protobuf_tempo
}  // namespace google

namespace TempoMapQuery {
enum LaneRelationship : int {
  LR_UNKNOWN = 0,
  SUCCESSOR = 1,
  PREDECESSOR = 2,
  NEIGHBOR = 3,
  LaneRelationship_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LaneRelationship_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

TEMPOMAPQUERY_API bool LaneRelationship_IsValid(int value);
TEMPOMAPQUERY_API extern const uint32_t LaneRelationship_internal_data_[];
constexpr LaneRelationship LaneRelationship_MIN = static_cast<LaneRelationship>(0);
constexpr LaneRelationship LaneRelationship_MAX = static_cast<LaneRelationship>(3);
constexpr int LaneRelationship_ARRAYSIZE = 3 + 1;
TEMPOMAPQUERY_API const ::google::protobuf_tempo::EnumDescriptor*
LaneRelationship_descriptor();
template <typename T>
const std::string& LaneRelationship_Name(T value) {
  static_assert(std::is_same<T, LaneRelationship>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LaneRelationship_Name().");
  return LaneRelationship_Name(static_cast<LaneRelationship>(value));
}
template <>
inline const std::string& LaneRelationship_Name(LaneRelationship value) {
  return ::google::protobuf_tempo::internal::NameOfDenseEnum<LaneRelationship_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool LaneRelationship_Parse(absl_tempo::string_view name, LaneRelationship* value) {
  return ::google::protobuf_tempo::internal::ParseNamedEnum<LaneRelationship>(
      LaneRelationship_descriptor(), name, value);
}
enum LaneAccessibility : int {
  LA_UNKNOWN = 0,
  GREEN = 1,
  YELLOW = 2,
  RED = 3,
  STOP_SIGN = 4,
  YIELD_SIGN = 5,
  NO_TRAFFIC_CONTROL = 6,
  LaneAccessibility_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LaneAccessibility_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

TEMPOMAPQUERY_API bool LaneAccessibility_IsValid(int value);
TEMPOMAPQUERY_API extern const uint32_t LaneAccessibility_internal_data_[];
constexpr LaneAccessibility LaneAccessibility_MIN = static_cast<LaneAccessibility>(0);
constexpr LaneAccessibility LaneAccessibility_MAX = static_cast<LaneAccessibility>(6);
constexpr int LaneAccessibility_ARRAYSIZE = 6 + 1;
TEMPOMAPQUERY_API const ::google::protobuf_tempo::EnumDescriptor*
LaneAccessibility_descriptor();
template <typename T>
const std::string& LaneAccessibility_Name(T value) {
  static_assert(std::is_same<T, LaneAccessibility>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LaneAccessibility_Name().");
  return LaneAccessibility_Name(static_cast<LaneAccessibility>(value));
}
template <>
inline const std::string& LaneAccessibility_Name(LaneAccessibility value) {
  return ::google::protobuf_tempo::internal::NameOfDenseEnum<LaneAccessibility_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool LaneAccessibility_Parse(absl_tempo::string_view name, LaneAccessibility* value) {
  return ::google::protobuf_tempo::internal::ParseNamedEnum<LaneAccessibility>(
      LaneAccessibility_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TEMPOMAPQUERY_API ZoneConnection final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMapQuery.ZoneConnection) */ {
 public:
  inline ZoneConnection() : ZoneConnection(nullptr) {}
  ~ZoneConnection() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ZoneConnection(::google::protobuf_tempo::internal::ConstantInitialized);

  inline ZoneConnection(const ZoneConnection& from)
      : ZoneConnection(nullptr, from) {}
  ZoneConnection(ZoneConnection&& from) noexcept
    : ZoneConnection() {
    *this = ::std::move(from);
  }

  inline ZoneConnection& operator=(const ZoneConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoneConnection& operator=(ZoneConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoneConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoneConnection* internal_default_instance() {
    return reinterpret_cast<const ZoneConnection*>(
               &_ZoneConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ZoneConnection& a, ZoneConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoneConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoneConnection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoneConnection* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoneConnection>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const ZoneConnection& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const ZoneConnection& from) {
    ZoneConnection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(ZoneConnection* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMapQuery.ZoneConnection";
  }
  protected:
  explicit ZoneConnection(::google::protobuf_tempo::Arena* arena);
  ZoneConnection(::google::protobuf_tempo::Arena* arena, const ZoneConnection& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:TempoMapQuery.ZoneConnection)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMAPQUERY_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::int32_t id_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMapQuery_2fMapQueries_2eproto;
};// -------------------------------------------------------------------

class TEMPOMAPQUERY_API TagFilter final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMapQuery.TagFilter) */ {
 public:
  inline TagFilter() : TagFilter(nullptr) {}
  ~TagFilter() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TagFilter(::google::protobuf_tempo::internal::ConstantInitialized);

  inline TagFilter(const TagFilter& from)
      : TagFilter(nullptr, from) {}
  TagFilter(TagFilter&& from) noexcept
    : TagFilter() {
    *this = ::std::move(from);
  }

  inline TagFilter& operator=(const TagFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagFilter& operator=(TagFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagFilter* internal_default_instance() {
    return reinterpret_cast<const TagFilter*>(
               &_TagFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TagFilter& a, TagFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(TagFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagFilter* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagFilter>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const TagFilter& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const TagFilter& from) {
    TagFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(TagFilter* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMapQuery.TagFilter";
  }
  protected:
  explicit TagFilter(::google::protobuf_tempo::Arena* arena);
  TagFilter(::google::protobuf_tempo::Arena* arena, const TagFilter& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnyTagsFieldNumber = 1,
    kAllTagsFieldNumber = 2,
    kNoneTagsFieldNumber = 4,
  };
  // repeated string any_tags = 1;
  int any_tags_size() const;
  private:
  int _internal_any_tags_size() const;

  public:
  void clear_any_tags() ;
  const std::string& any_tags(int index) const;
  std::string* mutable_any_tags(int index);
  void set_any_tags(int index, const std::string& value);
  void set_any_tags(int index, std::string&& value);
  void set_any_tags(int index, const char* value);
  void set_any_tags(int index, const char* value, std::size_t size);
  void set_any_tags(int index, absl_tempo::string_view value);
  std::string* add_any_tags();
  void add_any_tags(const std::string& value);
  void add_any_tags(std::string&& value);
  void add_any_tags(const char* value);
  void add_any_tags(const char* value, std::size_t size);
  void add_any_tags(absl_tempo::string_view value);
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& any_tags() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* mutable_any_tags();

  private:
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& _internal_any_tags() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* _internal_mutable_any_tags();

  public:
  // repeated string all_tags = 2;
  int all_tags_size() const;
  private:
  int _internal_all_tags_size() const;

  public:
  void clear_all_tags() ;
  const std::string& all_tags(int index) const;
  std::string* mutable_all_tags(int index);
  void set_all_tags(int index, const std::string& value);
  void set_all_tags(int index, std::string&& value);
  void set_all_tags(int index, const char* value);
  void set_all_tags(int index, const char* value, std::size_t size);
  void set_all_tags(int index, absl_tempo::string_view value);
  std::string* add_all_tags();
  void add_all_tags(const std::string& value);
  void add_all_tags(std::string&& value);
  void add_all_tags(const char* value);
  void add_all_tags(const char* value, std::size_t size);
  void add_all_tags(absl_tempo::string_view value);
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& all_tags() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* mutable_all_tags();

  private:
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& _internal_all_tags() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* _internal_mutable_all_tags();

  public:
  // repeated string none_tags = 4;
  int none_tags_size() const;
  private:
  int _internal_none_tags_size() const;

  public:
  void clear_none_tags() ;
  const std::string& none_tags(int index) const;
  std::string* mutable_none_tags(int index);
  void set_none_tags(int index, const std::string& value);
  void set_none_tags(int index, std::string&& value);
  void set_none_tags(int index, const char* value);
  void set_none_tags(int index, const char* value, std::size_t size);
  void set_none_tags(int index, absl_tempo::string_view value);
  std::string* add_none_tags();
  void add_none_tags(const std::string& value);
  void add_none_tags(std::string&& value);
  void add_none_tags(const char* value);
  void add_none_tags(const char* value, std::size_t size);
  void add_none_tags(absl_tempo::string_view value);
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& none_tags() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* mutable_none_tags();

  private:
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& _internal_none_tags() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* _internal_mutable_none_tags();

  public:
  // @@protoc_insertion_point(class_scope:TempoMapQuery.TagFilter)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      2, 3, 0,
      57, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMAPQUERY_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::RepeatedPtrField<std::string> any_tags_;
    ::google::protobuf_tempo::RepeatedPtrField<std::string> all_tags_;
    ::google::protobuf_tempo::RepeatedPtrField<std::string> none_tags_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMapQuery_2fMapQueries_2eproto;
};// -------------------------------------------------------------------

class TEMPOMAPQUERY_API LaneConnection final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMapQuery.LaneConnection) */ {
 public:
  inline LaneConnection() : LaneConnection(nullptr) {}
  ~LaneConnection() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneConnection(::google::protobuf_tempo::internal::ConstantInitialized);

  inline LaneConnection(const LaneConnection& from)
      : LaneConnection(nullptr, from) {}
  LaneConnection(LaneConnection&& from) noexcept
    : LaneConnection() {
    *this = ::std::move(from);
  }

  inline LaneConnection& operator=(const LaneConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneConnection& operator=(LaneConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneConnection* internal_default_instance() {
    return reinterpret_cast<const LaneConnection*>(
               &_LaneConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LaneConnection& a, LaneConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneConnection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneConnection* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneConnection>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const LaneConnection& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const LaneConnection& from) {
    LaneConnection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneConnection* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMapQuery.LaneConnection";
  }
  protected:
  explicit LaneConnection(::google::protobuf_tempo::Arena* arena);
  LaneConnection(::google::protobuf_tempo::Arena* arena, const LaneConnection& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kRelationshipFieldNumber = 3,
  };
  // int32 id = 2;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .TempoMapQuery.LaneRelationship relationship = 3;
  void clear_relationship() ;
  ::TempoMapQuery::LaneRelationship relationship() const;
  void set_relationship(::TempoMapQuery::LaneRelationship value);

  private:
  ::TempoMapQuery::LaneRelationship _internal_relationship() const;
  void _internal_set_relationship(::TempoMapQuery::LaneRelationship value);

  public:
  // @@protoc_insertion_point(class_scope:TempoMapQuery.LaneConnection)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMAPQUERY_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::int32_t id_;
    int relationship_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMapQuery_2fMapQueries_2eproto;
};// -------------------------------------------------------------------

class TEMPOMAPQUERY_API LaneAccessibilityResponse final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMapQuery.LaneAccessibilityResponse) */ {
 public:
  inline LaneAccessibilityResponse() : LaneAccessibilityResponse(nullptr) {}
  ~LaneAccessibilityResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneAccessibilityResponse(::google::protobuf_tempo::internal::ConstantInitialized);

  inline LaneAccessibilityResponse(const LaneAccessibilityResponse& from)
      : LaneAccessibilityResponse(nullptr, from) {}
  LaneAccessibilityResponse(LaneAccessibilityResponse&& from) noexcept
    : LaneAccessibilityResponse() {
    *this = ::std::move(from);
  }

  inline LaneAccessibilityResponse& operator=(const LaneAccessibilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAccessibilityResponse& operator=(LaneAccessibilityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAccessibilityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAccessibilityResponse* internal_default_instance() {
    return reinterpret_cast<const LaneAccessibilityResponse*>(
               &_LaneAccessibilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LaneAccessibilityResponse& a, LaneAccessibilityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAccessibilityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAccessibilityResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAccessibilityResponse* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAccessibilityResponse>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const LaneAccessibilityResponse& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const LaneAccessibilityResponse& from) {
    LaneAccessibilityResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneAccessibilityResponse* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMapQuery.LaneAccessibilityResponse";
  }
  protected:
  explicit LaneAccessibilityResponse(::google::protobuf_tempo::Arena* arena);
  LaneAccessibilityResponse(::google::protobuf_tempo::Arena* arena, const LaneAccessibilityResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessibilityFieldNumber = 1,
  };
  // .TempoMapQuery.LaneAccessibility accessibility = 1;
  void clear_accessibility() ;
  ::TempoMapQuery::LaneAccessibility accessibility() const;
  void set_accessibility(::TempoMapQuery::LaneAccessibility value);

  private:
  ::TempoMapQuery::LaneAccessibility _internal_accessibility() const;
  void _internal_set_accessibility(::TempoMapQuery::LaneAccessibility value);

  public:
  // @@protoc_insertion_point(class_scope:TempoMapQuery.LaneAccessibilityResponse)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMAPQUERY_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    int accessibility_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMapQuery_2fMapQueries_2eproto;
};// -------------------------------------------------------------------

class TEMPOMAPQUERY_API LaneAccessibilityRequest final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMapQuery.LaneAccessibilityRequest) */ {
 public:
  inline LaneAccessibilityRequest() : LaneAccessibilityRequest(nullptr) {}
  ~LaneAccessibilityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneAccessibilityRequest(::google::protobuf_tempo::internal::ConstantInitialized);

  inline LaneAccessibilityRequest(const LaneAccessibilityRequest& from)
      : LaneAccessibilityRequest(nullptr, from) {}
  LaneAccessibilityRequest(LaneAccessibilityRequest&& from) noexcept
    : LaneAccessibilityRequest() {
    *this = ::std::move(from);
  }

  inline LaneAccessibilityRequest& operator=(const LaneAccessibilityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAccessibilityRequest& operator=(LaneAccessibilityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAccessibilityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAccessibilityRequest* internal_default_instance() {
    return reinterpret_cast<const LaneAccessibilityRequest*>(
               &_LaneAccessibilityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LaneAccessibilityRequest& a, LaneAccessibilityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAccessibilityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAccessibilityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAccessibilityRequest* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAccessibilityRequest>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const LaneAccessibilityRequest& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const LaneAccessibilityRequest& from) {
    LaneAccessibilityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneAccessibilityRequest* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMapQuery.LaneAccessibilityRequest";
  }
  protected:
  explicit LaneAccessibilityRequest(::google::protobuf_tempo::Arena* arena);
  LaneAccessibilityRequest(::google::protobuf_tempo::Arena* arena, const LaneAccessibilityRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromIdFieldNumber = 1,
    kToIdFieldNumber = 2,
  };
  // int32 from_id = 1;
  void clear_from_id() ;
  ::int32_t from_id() const;
  void set_from_id(::int32_t value);

  private:
  ::int32_t _internal_from_id() const;
  void _internal_set_from_id(::int32_t value);

  public:
  // int32 to_id = 2;
  void clear_to_id() ;
  ::int32_t to_id() const;
  void set_to_id(::int32_t value);

  private:
  ::int32_t _internal_to_id() const;
  void _internal_set_to_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:TempoMapQuery.LaneAccessibilityRequest)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMAPQUERY_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::int32_t from_id_;
    ::int32_t to_id_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMapQuery_2fMapQueries_2eproto;
};// -------------------------------------------------------------------

class TEMPOMAPQUERY_API ZoneDataRequest final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMapQuery.ZoneDataRequest) */ {
 public:
  inline ZoneDataRequest() : ZoneDataRequest(nullptr) {}
  ~ZoneDataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ZoneDataRequest(::google::protobuf_tempo::internal::ConstantInitialized);

  inline ZoneDataRequest(const ZoneDataRequest& from)
      : ZoneDataRequest(nullptr, from) {}
  ZoneDataRequest(ZoneDataRequest&& from) noexcept
    : ZoneDataRequest() {
    *this = ::std::move(from);
  }

  inline ZoneDataRequest& operator=(const ZoneDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoneDataRequest& operator=(ZoneDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoneDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoneDataRequest* internal_default_instance() {
    return reinterpret_cast<const ZoneDataRequest*>(
               &_ZoneDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ZoneDataRequest& a, ZoneDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoneDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoneDataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoneDataRequest* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoneDataRequest>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const ZoneDataRequest& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const ZoneDataRequest& from) {
    ZoneDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(ZoneDataRequest* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMapQuery.ZoneDataRequest";
  }
  protected:
  explicit ZoneDataRequest(::google::protobuf_tempo::Arena* arena);
  ZoneDataRequest(::google::protobuf_tempo::Arena* arena, const ZoneDataRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFilterFieldNumber = 1,
    kCenterFieldNumber = 2,
    kRadiusFieldNumber = 3,
  };
  // .TempoMapQuery.TagFilter tag_filter = 1;
  bool has_tag_filter() const;
  void clear_tag_filter() ;
  const ::TempoMapQuery::TagFilter& tag_filter() const;
  PROTOBUF_NODISCARD ::TempoMapQuery::TagFilter* release_tag_filter();
  ::TempoMapQuery::TagFilter* mutable_tag_filter();
  void set_allocated_tag_filter(::TempoMapQuery::TagFilter* value);
  void unsafe_arena_set_allocated_tag_filter(::TempoMapQuery::TagFilter* value);
  ::TempoMapQuery::TagFilter* unsafe_arena_release_tag_filter();

  private:
  const ::TempoMapQuery::TagFilter& _internal_tag_filter() const;
  ::TempoMapQuery::TagFilter* _internal_mutable_tag_filter();

  public:
  // .TempoScripting.Vector center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::TempoScripting::Vector& center() const;
  PROTOBUF_NODISCARD ::TempoScripting::Vector* release_center();
  ::TempoScripting::Vector* mutable_center();
  void set_allocated_center(::TempoScripting::Vector* value);
  void unsafe_arena_set_allocated_center(::TempoScripting::Vector* value);
  ::TempoScripting::Vector* unsafe_arena_release_center();

  private:
  const ::TempoScripting::Vector& _internal_center() const;
  ::TempoScripting::Vector* _internal_mutable_center();

  public:
  // double radius = 3;
  void clear_radius() ;
  double radius() const;
  void set_radius(double value);

  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);

  public:
  // @@protoc_insertion_point(class_scope:TempoMapQuery.ZoneDataRequest)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMAPQUERY_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    ::TempoMapQuery::TagFilter* tag_filter_;
    ::TempoScripting::Vector* center_;
    double radius_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMapQuery_2fMapQueries_2eproto;
};// -------------------------------------------------------------------

class TEMPOMAPQUERY_API ZoneData final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMapQuery.ZoneData) */ {
 public:
  inline ZoneData() : ZoneData(nullptr) {}
  ~ZoneData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ZoneData(::google::protobuf_tempo::internal::ConstantInitialized);

  inline ZoneData(const ZoneData& from)
      : ZoneData(nullptr, from) {}
  ZoneData(ZoneData&& from) noexcept
    : ZoneData() {
    *this = ::std::move(from);
  }

  inline ZoneData& operator=(const ZoneData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoneData& operator=(ZoneData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoneData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoneData* internal_default_instance() {
    return reinterpret_cast<const ZoneData*>(
               &_ZoneData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ZoneData& a, ZoneData& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoneData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoneData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoneData* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoneData>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const ZoneData& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const ZoneData& from) {
    ZoneData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(ZoneData* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMapQuery.ZoneData";
  }
  protected:
  explicit ZoneData(::google::protobuf_tempo::Arena* arena);
  ZoneData(::google::protobuf_tempo::Arena* arena, const ZoneData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 2,
    kBoundaryPointsFieldNumber = 4,
    kConnectionsFieldNumber = 5,
    kIdFieldNumber = 1,
  };
  // repeated string tags = 2;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl_tempo::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl_tempo::string_view value);
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // repeated .TempoScripting.Vector boundary_points = 4;
  int boundary_points_size() const;
  private:
  int _internal_boundary_points_size() const;

  public:
  void clear_boundary_points() ;
  ::TempoScripting::Vector* mutable_boundary_points(int index);
  ::google::protobuf_tempo::RepeatedPtrField< ::TempoScripting::Vector >*
      mutable_boundary_points();
  private:
  const ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>& _internal_boundary_points() const;
  ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>* _internal_mutable_boundary_points();
  public:
  const ::TempoScripting::Vector& boundary_points(int index) const;
  ::TempoScripting::Vector* add_boundary_points();
  const ::google::protobuf_tempo::RepeatedPtrField< ::TempoScripting::Vector >&
      boundary_points() const;
  // repeated .TempoMapQuery.ZoneConnection connections = 5;
  int connections_size() const;
  private:
  int _internal_connections_size() const;

  public:
  void clear_connections() ;
  ::TempoMapQuery::ZoneConnection* mutable_connections(int index);
  ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::ZoneConnection >*
      mutable_connections();
  private:
  const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneConnection>& _internal_connections() const;
  ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneConnection>* _internal_mutable_connections();
  public:
  const ::TempoMapQuery::ZoneConnection& connections(int index) const;
  ::TempoMapQuery::ZoneConnection* add_connections();
  const ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::ZoneConnection >&
      connections() const;
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:TempoMapQuery.ZoneData)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      3, 4, 2,
      35, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMAPQUERY_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::RepeatedPtrField<std::string> tags_;
    ::google::protobuf_tempo::RepeatedPtrField< ::TempoScripting::Vector > boundary_points_;
    ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::ZoneConnection > connections_;
    ::int32_t id_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMapQuery_2fMapQueries_2eproto;
};// -------------------------------------------------------------------

class TEMPOMAPQUERY_API LaneDataRequest final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMapQuery.LaneDataRequest) */ {
 public:
  inline LaneDataRequest() : LaneDataRequest(nullptr) {}
  ~LaneDataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneDataRequest(::google::protobuf_tempo::internal::ConstantInitialized);

  inline LaneDataRequest(const LaneDataRequest& from)
      : LaneDataRequest(nullptr, from) {}
  LaneDataRequest(LaneDataRequest&& from) noexcept
    : LaneDataRequest() {
    *this = ::std::move(from);
  }

  inline LaneDataRequest& operator=(const LaneDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneDataRequest& operator=(LaneDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneDataRequest* internal_default_instance() {
    return reinterpret_cast<const LaneDataRequest*>(
               &_LaneDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LaneDataRequest& a, LaneDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneDataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneDataRequest* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneDataRequest>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const LaneDataRequest& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const LaneDataRequest& from) {
    LaneDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneDataRequest* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMapQuery.LaneDataRequest";
  }
  protected:
  explicit LaneDataRequest(::google::protobuf_tempo::Arena* arena);
  LaneDataRequest(::google::protobuf_tempo::Arena* arena, const LaneDataRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFilterFieldNumber = 1,
    kCenterFieldNumber = 2,
    kRadiusFieldNumber = 3,
  };
  // .TempoMapQuery.TagFilter tag_filter = 1;
  bool has_tag_filter() const;
  void clear_tag_filter() ;
  const ::TempoMapQuery::TagFilter& tag_filter() const;
  PROTOBUF_NODISCARD ::TempoMapQuery::TagFilter* release_tag_filter();
  ::TempoMapQuery::TagFilter* mutable_tag_filter();
  void set_allocated_tag_filter(::TempoMapQuery::TagFilter* value);
  void unsafe_arena_set_allocated_tag_filter(::TempoMapQuery::TagFilter* value);
  ::TempoMapQuery::TagFilter* unsafe_arena_release_tag_filter();

  private:
  const ::TempoMapQuery::TagFilter& _internal_tag_filter() const;
  ::TempoMapQuery::TagFilter* _internal_mutable_tag_filter();

  public:
  // .TempoScripting.Vector2D center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::TempoScripting::Vector2D& center() const;
  PROTOBUF_NODISCARD ::TempoScripting::Vector2D* release_center();
  ::TempoScripting::Vector2D* mutable_center();
  void set_allocated_center(::TempoScripting::Vector2D* value);
  void unsafe_arena_set_allocated_center(::TempoScripting::Vector2D* value);
  ::TempoScripting::Vector2D* unsafe_arena_release_center();

  private:
  const ::TempoScripting::Vector2D& _internal_center() const;
  ::TempoScripting::Vector2D* _internal_mutable_center();

  public:
  // double radius = 3;
  void clear_radius() ;
  double radius() const;
  void set_radius(double value);

  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);

  public:
  // @@protoc_insertion_point(class_scope:TempoMapQuery.LaneDataRequest)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMAPQUERY_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    ::TempoMapQuery::TagFilter* tag_filter_;
    ::TempoScripting::Vector2D* center_;
    double radius_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMapQuery_2fMapQueries_2eproto;
};// -------------------------------------------------------------------

class TEMPOMAPQUERY_API LaneData final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMapQuery.LaneData) */ {
 public:
  inline LaneData() : LaneData(nullptr) {}
  ~LaneData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneData(::google::protobuf_tempo::internal::ConstantInitialized);

  inline LaneData(const LaneData& from)
      : LaneData(nullptr, from) {}
  LaneData(LaneData&& from) noexcept
    : LaneData() {
    *this = ::std::move(from);
  }

  inline LaneData& operator=(const LaneData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneData& operator=(LaneData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneData* internal_default_instance() {
    return reinterpret_cast<const LaneData*>(
               &_LaneData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LaneData& a, LaneData& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneData* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneData>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const LaneData& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const LaneData& from) {
    LaneData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneData* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMapQuery.LaneData";
  }
  protected:
  explicit LaneData(::google::protobuf_tempo::Arena* arena);
  LaneData(::google::protobuf_tempo::Arena* arena, const LaneData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 2,
    kCenterPointsFieldNumber = 3,
    kConnectionsFieldNumber = 5,
    kWidthFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // repeated string tags = 2;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl_tempo::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl_tempo::string_view value);
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf_tempo::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf_tempo::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // repeated .TempoScripting.Vector center_points = 3;
  int center_points_size() const;
  private:
  int _internal_center_points_size() const;

  public:
  void clear_center_points() ;
  ::TempoScripting::Vector* mutable_center_points(int index);
  ::google::protobuf_tempo::RepeatedPtrField< ::TempoScripting::Vector >*
      mutable_center_points();
  private:
  const ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>& _internal_center_points() const;
  ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>* _internal_mutable_center_points();
  public:
  const ::TempoScripting::Vector& center_points(int index) const;
  ::TempoScripting::Vector* add_center_points();
  const ::google::protobuf_tempo::RepeatedPtrField< ::TempoScripting::Vector >&
      center_points() const;
  // repeated .TempoMapQuery.LaneConnection connections = 5;
  int connections_size() const;
  private:
  int _internal_connections_size() const;

  public:
  void clear_connections() ;
  ::TempoMapQuery::LaneConnection* mutable_connections(int index);
  ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::LaneConnection >*
      mutable_connections();
  private:
  const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneConnection>& _internal_connections() const;
  ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneConnection>* _internal_mutable_connections();
  public:
  const ::TempoMapQuery::LaneConnection& connections(int index) const;
  ::TempoMapQuery::LaneConnection* add_connections();
  const ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::LaneConnection >&
      connections() const;
  // double width = 4;
  void clear_width() ;
  double width() const;
  void set_width(double value);

  private:
  double _internal_width() const;
  void _internal_set_width(double value);

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:TempoMapQuery.LaneData)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      3, 5, 2,
      35, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMAPQUERY_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::RepeatedPtrField<std::string> tags_;
    ::google::protobuf_tempo::RepeatedPtrField< ::TempoScripting::Vector > center_points_;
    ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::LaneConnection > connections_;
    double width_;
    ::int32_t id_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMapQuery_2fMapQueries_2eproto;
};// -------------------------------------------------------------------

class TEMPOMAPQUERY_API ZoneDataResponse final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMapQuery.ZoneDataResponse) */ {
 public:
  inline ZoneDataResponse() : ZoneDataResponse(nullptr) {}
  ~ZoneDataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ZoneDataResponse(::google::protobuf_tempo::internal::ConstantInitialized);

  inline ZoneDataResponse(const ZoneDataResponse& from)
      : ZoneDataResponse(nullptr, from) {}
  ZoneDataResponse(ZoneDataResponse&& from) noexcept
    : ZoneDataResponse() {
    *this = ::std::move(from);
  }

  inline ZoneDataResponse& operator=(const ZoneDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoneDataResponse& operator=(ZoneDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoneDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoneDataResponse* internal_default_instance() {
    return reinterpret_cast<const ZoneDataResponse*>(
               &_ZoneDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ZoneDataResponse& a, ZoneDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoneDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoneDataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoneDataResponse* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoneDataResponse>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const ZoneDataResponse& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const ZoneDataResponse& from) {
    ZoneDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(ZoneDataResponse* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMapQuery.ZoneDataResponse";
  }
  protected:
  explicit ZoneDataResponse(::google::protobuf_tempo::Arena* arena);
  ZoneDataResponse(::google::protobuf_tempo::Arena* arena, const ZoneDataResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZonesFieldNumber = 1,
  };
  // repeated .TempoMapQuery.ZoneData zones = 1;
  int zones_size() const;
  private:
  int _internal_zones_size() const;

  public:
  void clear_zones() ;
  ::TempoMapQuery::ZoneData* mutable_zones(int index);
  ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::ZoneData >*
      mutable_zones();
  private:
  const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneData>& _internal_zones() const;
  ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneData>* _internal_mutable_zones();
  public:
  const ::TempoMapQuery::ZoneData& zones(int index) const;
  ::TempoMapQuery::ZoneData* add_zones();
  const ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::ZoneData >&
      zones() const;
  // @@protoc_insertion_point(class_scope:TempoMapQuery.ZoneDataResponse)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMAPQUERY_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::ZoneData > zones_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMapQuery_2fMapQueries_2eproto;
};// -------------------------------------------------------------------

class TEMPOMAPQUERY_API LaneDataResponse final :
    public ::google::protobuf_tempo::Message /* @@protoc_insertion_point(class_definition:TempoMapQuery.LaneDataResponse) */ {
 public:
  inline LaneDataResponse() : LaneDataResponse(nullptr) {}
  ~LaneDataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneDataResponse(::google::protobuf_tempo::internal::ConstantInitialized);

  inline LaneDataResponse(const LaneDataResponse& from)
      : LaneDataResponse(nullptr, from) {}
  LaneDataResponse(LaneDataResponse&& from) noexcept
    : LaneDataResponse() {
    *this = ::std::move(from);
  }

  inline LaneDataResponse& operator=(const LaneDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneDataResponse& operator=(LaneDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_tempo::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_tempo::UnknownFieldSet>(::google::protobuf_tempo::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_tempo::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_tempo::UnknownFieldSet>();
  }

  static const ::google::protobuf_tempo::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_tempo::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_tempo::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneDataResponse* internal_default_instance() {
    return reinterpret_cast<const LaneDataResponse*>(
               &_LaneDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LaneDataResponse& a, LaneDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_tempo::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneDataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneDataResponse* New(::google::protobuf_tempo::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneDataResponse>(arena);
  }
  using ::google::protobuf_tempo::Message::CopyFrom;
  void CopyFrom(const LaneDataResponse& from);
  using ::google::protobuf_tempo::Message::MergeFrom;
  void MergeFrom( const LaneDataResponse& from) {
    LaneDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_tempo::Message& to_msg, const ::google::protobuf_tempo::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_tempo::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_tempo::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_tempo::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_tempo::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneDataResponse* other);

  private:
  friend class ::google::protobuf_tempo::internal::AnyMetadata;
  static ::absl_tempo::string_view FullMessageName() {
    return "TempoMapQuery.LaneDataResponse";
  }
  protected:
  explicit LaneDataResponse(::google::protobuf_tempo::Arena* arena);
  LaneDataResponse(::google::protobuf_tempo::Arena* arena, const LaneDataResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_tempo::Message::ClassData*GetClassData() const final;

  ::google::protobuf_tempo::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanesFieldNumber = 1,
  };
  // repeated .TempoMapQuery.LaneData lanes = 1;
  int lanes_size() const;
  private:
  int _internal_lanes_size() const;

  public:
  void clear_lanes() ;
  ::TempoMapQuery::LaneData* mutable_lanes(int index);
  ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::LaneData >*
      mutable_lanes();
  private:
  const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneData>& _internal_lanes() const;
  ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneData>* _internal_mutable_lanes();
  public:
  const ::TempoMapQuery::LaneData& lanes(int index) const;
  ::TempoMapQuery::LaneData* add_lanes();
  const ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::LaneData >&
      lanes() const;
  // @@protoc_insertion_point(class_scope:TempoMapQuery.LaneDataResponse)
 private:
  class _Internal;

  friend class ::google::protobuf_tempo::internal::TcParser;
  static const ::google::protobuf_tempo::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_tempo::MessageLite;
  friend class ::google::protobuf_tempo::Arena;
  template <typename T>
  friend class ::google::protobuf_tempo::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct TEMPOMAPQUERY_API Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_tempo::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena);
        inline explicit Impl_(::google::protobuf_tempo::internal::InternalVisibility visibility,
                              ::google::protobuf_tempo::Arena* arena, const Impl_& from);
    ::google::protobuf_tempo::RepeatedPtrField< ::TempoMapQuery::LaneData > lanes_;
    mutable ::google::protobuf_tempo::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TempoMapQuery_2fMapQueries_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TagFilter

// repeated string any_tags = 1;
inline int TagFilter::_internal_any_tags_size() const {
  return _internal_any_tags().size();
}
inline int TagFilter::any_tags_size() const {
  return _internal_any_tags_size();
}
inline void TagFilter::clear_any_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.any_tags_.Clear();
}
inline std::string* TagFilter::add_any_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_any_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:TempoMapQuery.TagFilter.any_tags)
  return _s;
}
inline const std::string& TagFilter::any_tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.TagFilter.any_tags)
  return _internal_any_tags().Get(index);
}
inline std::string* TagFilter::mutable_any_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.TagFilter.any_tags)
  return _internal_mutable_any_tags()->Mutable(index);
}
inline void TagFilter::set_any_tags(int index, const std::string& value) {
  _internal_mutable_any_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.TagFilter.any_tags)
}
inline void TagFilter::set_any_tags(int index, std::string&& value) {
  _internal_mutable_any_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TempoMapQuery.TagFilter.any_tags)
}
inline void TagFilter::set_any_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_any_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TempoMapQuery.TagFilter.any_tags)
}
inline void TagFilter::set_any_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_any_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TempoMapQuery.TagFilter.any_tags)
}
inline void TagFilter::set_any_tags(int index, absl_tempo::string_view value) {
  _internal_mutable_any_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:TempoMapQuery.TagFilter.any_tags)
}
inline void TagFilter::add_any_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_any_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:TempoMapQuery.TagFilter.any_tags)
}
inline void TagFilter::add_any_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_any_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:TempoMapQuery.TagFilter.any_tags)
}
inline void TagFilter::add_any_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_any_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TempoMapQuery.TagFilter.any_tags)
}
inline void TagFilter::add_any_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_any_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TempoMapQuery.TagFilter.any_tags)
}
inline void TagFilter::add_any_tags(absl_tempo::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_any_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:TempoMapQuery.TagFilter.any_tags)
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
TagFilter::any_tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMapQuery.TagFilter.any_tags)
  return _internal_any_tags();
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
TagFilter::mutable_any_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMapQuery.TagFilter.any_tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_any_tags();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
TagFilter::_internal_any_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.any_tags_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
TagFilter::_internal_mutable_any_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.any_tags_;
}

// repeated string all_tags = 2;
inline int TagFilter::_internal_all_tags_size() const {
  return _internal_all_tags().size();
}
inline int TagFilter::all_tags_size() const {
  return _internal_all_tags_size();
}
inline void TagFilter::clear_all_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.all_tags_.Clear();
}
inline std::string* TagFilter::add_all_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_all_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:TempoMapQuery.TagFilter.all_tags)
  return _s;
}
inline const std::string& TagFilter::all_tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.TagFilter.all_tags)
  return _internal_all_tags().Get(index);
}
inline std::string* TagFilter::mutable_all_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.TagFilter.all_tags)
  return _internal_mutable_all_tags()->Mutable(index);
}
inline void TagFilter::set_all_tags(int index, const std::string& value) {
  _internal_mutable_all_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.TagFilter.all_tags)
}
inline void TagFilter::set_all_tags(int index, std::string&& value) {
  _internal_mutable_all_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TempoMapQuery.TagFilter.all_tags)
}
inline void TagFilter::set_all_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_all_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TempoMapQuery.TagFilter.all_tags)
}
inline void TagFilter::set_all_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_all_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TempoMapQuery.TagFilter.all_tags)
}
inline void TagFilter::set_all_tags(int index, absl_tempo::string_view value) {
  _internal_mutable_all_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:TempoMapQuery.TagFilter.all_tags)
}
inline void TagFilter::add_all_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_all_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:TempoMapQuery.TagFilter.all_tags)
}
inline void TagFilter::add_all_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_all_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:TempoMapQuery.TagFilter.all_tags)
}
inline void TagFilter::add_all_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_all_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TempoMapQuery.TagFilter.all_tags)
}
inline void TagFilter::add_all_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_all_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TempoMapQuery.TagFilter.all_tags)
}
inline void TagFilter::add_all_tags(absl_tempo::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_all_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:TempoMapQuery.TagFilter.all_tags)
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
TagFilter::all_tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMapQuery.TagFilter.all_tags)
  return _internal_all_tags();
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
TagFilter::mutable_all_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMapQuery.TagFilter.all_tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_all_tags();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
TagFilter::_internal_all_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.all_tags_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
TagFilter::_internal_mutable_all_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.all_tags_;
}

// repeated string none_tags = 4;
inline int TagFilter::_internal_none_tags_size() const {
  return _internal_none_tags().size();
}
inline int TagFilter::none_tags_size() const {
  return _internal_none_tags_size();
}
inline void TagFilter::clear_none_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.none_tags_.Clear();
}
inline std::string* TagFilter::add_none_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_none_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:TempoMapQuery.TagFilter.none_tags)
  return _s;
}
inline const std::string& TagFilter::none_tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.TagFilter.none_tags)
  return _internal_none_tags().Get(index);
}
inline std::string* TagFilter::mutable_none_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.TagFilter.none_tags)
  return _internal_mutable_none_tags()->Mutable(index);
}
inline void TagFilter::set_none_tags(int index, const std::string& value) {
  _internal_mutable_none_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.TagFilter.none_tags)
}
inline void TagFilter::set_none_tags(int index, std::string&& value) {
  _internal_mutable_none_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TempoMapQuery.TagFilter.none_tags)
}
inline void TagFilter::set_none_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_none_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TempoMapQuery.TagFilter.none_tags)
}
inline void TagFilter::set_none_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_none_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TempoMapQuery.TagFilter.none_tags)
}
inline void TagFilter::set_none_tags(int index, absl_tempo::string_view value) {
  _internal_mutable_none_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:TempoMapQuery.TagFilter.none_tags)
}
inline void TagFilter::add_none_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_none_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:TempoMapQuery.TagFilter.none_tags)
}
inline void TagFilter::add_none_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_none_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:TempoMapQuery.TagFilter.none_tags)
}
inline void TagFilter::add_none_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_none_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TempoMapQuery.TagFilter.none_tags)
}
inline void TagFilter::add_none_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_none_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TempoMapQuery.TagFilter.none_tags)
}
inline void TagFilter::add_none_tags(absl_tempo::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_none_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:TempoMapQuery.TagFilter.none_tags)
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
TagFilter::none_tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMapQuery.TagFilter.none_tags)
  return _internal_none_tags();
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
TagFilter::mutable_none_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMapQuery.TagFilter.none_tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_none_tags();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
TagFilter::_internal_none_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.none_tags_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
TagFilter::_internal_mutable_none_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.none_tags_;
}

// -------------------------------------------------------------------

// LaneDataRequest

// .TempoMapQuery.TagFilter tag_filter = 1;
inline bool LaneDataRequest::has_tag_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tag_filter_ != nullptr);
  return value;
}
inline void LaneDataRequest::clear_tag_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tag_filter_ != nullptr) _impl_.tag_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TempoMapQuery::TagFilter& LaneDataRequest::_internal_tag_filter() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TempoMapQuery::TagFilter* p = _impl_.tag_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::TempoMapQuery::TagFilter&>(::TempoMapQuery::_TagFilter_default_instance_);
}
inline const ::TempoMapQuery::TagFilter& LaneDataRequest::tag_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneDataRequest.tag_filter)
  return _internal_tag_filter();
}
inline void LaneDataRequest::unsafe_arena_set_allocated_tag_filter(::TempoMapQuery::TagFilter* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.tag_filter_);
  }
  _impl_.tag_filter_ = reinterpret_cast<::TempoMapQuery::TagFilter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TempoMapQuery.LaneDataRequest.tag_filter)
}
inline ::TempoMapQuery::TagFilter* LaneDataRequest::release_tag_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TempoMapQuery::TagFilter* released = _impl_.tag_filter_;
  _impl_.tag_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(released);
  released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TempoMapQuery::TagFilter* LaneDataRequest::unsafe_arena_release_tag_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TempoMapQuery.LaneDataRequest.tag_filter)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TempoMapQuery::TagFilter* temp = _impl_.tag_filter_;
  _impl_.tag_filter_ = nullptr;
  return temp;
}
inline ::TempoMapQuery::TagFilter* LaneDataRequest::_internal_mutable_tag_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tag_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::TempoMapQuery::TagFilter>(GetArena());
    _impl_.tag_filter_ = reinterpret_cast<::TempoMapQuery::TagFilter*>(p);
  }
  return _impl_.tag_filter_;
}
inline ::TempoMapQuery::TagFilter* LaneDataRequest::mutable_tag_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TempoMapQuery::TagFilter* _msg = _internal_mutable_tag_filter();
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.LaneDataRequest.tag_filter)
  return _msg;
}
inline void LaneDataRequest::set_allocated_tag_filter(::TempoMapQuery::TagFilter* value) {
  ::google::protobuf_tempo::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::TempoMapQuery::TagFilter*>(_impl_.tag_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf_tempo::Arena* submessage_arena = reinterpret_cast<::TempoMapQuery::TagFilter*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_tempo::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tag_filter_ = reinterpret_cast<::TempoMapQuery::TagFilter*>(value);
  // @@protoc_insertion_point(field_set_allocated:TempoMapQuery.LaneDataRequest.tag_filter)
}

// .TempoScripting.Vector2D center = 2;
inline bool LaneDataRequest::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline const ::TempoScripting::Vector2D& LaneDataRequest::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TempoScripting::Vector2D* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::TempoScripting::Vector2D&>(::TempoScripting::_Vector2D_default_instance_);
}
inline const ::TempoScripting::Vector2D& LaneDataRequest::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneDataRequest.center)
  return _internal_center();
}
inline void LaneDataRequest::unsafe_arena_set_allocated_center(::TempoScripting::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::TempoScripting::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TempoMapQuery.LaneDataRequest.center)
}
inline ::TempoScripting::Vector2D* LaneDataRequest::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TempoScripting::Vector2D* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(released);
  released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TempoScripting::Vector2D* LaneDataRequest::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TempoMapQuery.LaneDataRequest.center)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TempoScripting::Vector2D* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::TempoScripting::Vector2D* LaneDataRequest::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::TempoScripting::Vector2D>(GetArena());
    _impl_.center_ = reinterpret_cast<::TempoScripting::Vector2D*>(p);
  }
  return _impl_.center_;
}
inline ::TempoScripting::Vector2D* LaneDataRequest::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TempoScripting::Vector2D* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.LaneDataRequest.center)
  return _msg;
}
inline void LaneDataRequest::set_allocated_center(::TempoScripting::Vector2D* value) {
  ::google::protobuf_tempo::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf_tempo::Arena* submessage_arena = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_tempo::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.center_ = reinterpret_cast<::TempoScripting::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:TempoMapQuery.LaneDataRequest.center)
}

// double radius = 3;
inline void LaneDataRequest::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.radius_ = 0;
}
inline double LaneDataRequest::radius() const {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneDataRequest.radius)
  return _internal_radius();
}
inline void LaneDataRequest::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.LaneDataRequest.radius)
}
inline double LaneDataRequest::_internal_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.radius_;
}
inline void LaneDataRequest::_internal_set_radius(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.radius_ = value;
}

// -------------------------------------------------------------------

// LaneConnection

// int32 id = 2;
inline void LaneConnection::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t LaneConnection::id() const {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneConnection.id)
  return _internal_id();
}
inline void LaneConnection::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.LaneConnection.id)
}
inline ::int32_t LaneConnection::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void LaneConnection::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// .TempoMapQuery.LaneRelationship relationship = 3;
inline void LaneConnection::clear_relationship() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relationship_ = 0;
}
inline ::TempoMapQuery::LaneRelationship LaneConnection::relationship() const {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneConnection.relationship)
  return _internal_relationship();
}
inline void LaneConnection::set_relationship(::TempoMapQuery::LaneRelationship value) {
  _internal_set_relationship(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.LaneConnection.relationship)
}
inline ::TempoMapQuery::LaneRelationship LaneConnection::_internal_relationship() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::TempoMapQuery::LaneRelationship>(_impl_.relationship_);
}
inline void LaneConnection::_internal_set_relationship(::TempoMapQuery::LaneRelationship value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.relationship_ = value;
}

// -------------------------------------------------------------------

// LaneData

// int32 id = 1;
inline void LaneData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t LaneData::id() const {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneData.id)
  return _internal_id();
}
inline void LaneData::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.LaneData.id)
}
inline ::int32_t LaneData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void LaneData::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// repeated string tags = 2;
inline int LaneData::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int LaneData::tags_size() const {
  return _internal_tags_size();
}
inline void LaneData::clear_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_.Clear();
}
inline std::string* LaneData::add_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:TempoMapQuery.LaneData.tags)
  return _s;
}
inline const std::string& LaneData::tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneData.tags)
  return _internal_tags().Get(index);
}
inline std::string* LaneData::mutable_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.LaneData.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void LaneData::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.LaneData.tags)
}
inline void LaneData::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TempoMapQuery.LaneData.tags)
}
inline void LaneData::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TempoMapQuery.LaneData.tags)
}
inline void LaneData::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TempoMapQuery.LaneData.tags)
}
inline void LaneData::set_tags(int index, absl_tempo::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:TempoMapQuery.LaneData.tags)
}
inline void LaneData::add_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:TempoMapQuery.LaneData.tags)
}
inline void LaneData::add_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:TempoMapQuery.LaneData.tags)
}
inline void LaneData::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TempoMapQuery.LaneData.tags)
}
inline void LaneData::add_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TempoMapQuery.LaneData.tags)
}
inline void LaneData::add_tags(absl_tempo::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:TempoMapQuery.LaneData.tags)
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
LaneData::tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMapQuery.LaneData.tags)
  return _internal_tags();
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
LaneData::mutable_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMapQuery.LaneData.tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tags();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
LaneData::_internal_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
LaneData::_internal_mutable_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tags_;
}

// repeated .TempoScripting.Vector center_points = 3;
inline int LaneData::_internal_center_points_size() const {
  return _internal_center_points().size();
}
inline int LaneData::center_points_size() const {
  return _internal_center_points_size();
}
inline ::TempoScripting::Vector* LaneData::mutable_center_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.LaneData.center_points)
  return _internal_mutable_center_points()->Mutable(index);
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>* LaneData::mutable_center_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMapQuery.LaneData.center_points)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_center_points();
}
inline const ::TempoScripting::Vector& LaneData::center_points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneData.center_points)
  return _internal_center_points().Get(index);
}
inline ::TempoScripting::Vector* LaneData::add_center_points() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TempoScripting::Vector* _add = _internal_mutable_center_points()->Add();
  // @@protoc_insertion_point(field_add:TempoMapQuery.LaneData.center_points)
  return _add;
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>& LaneData::center_points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMapQuery.LaneData.center_points)
  return _internal_center_points();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>&
LaneData::_internal_center_points() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.center_points_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>*
LaneData::_internal_mutable_center_points() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.center_points_;
}

// double width = 4;
inline void LaneData::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline double LaneData::width() const {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneData.width)
  return _internal_width();
}
inline void LaneData::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.LaneData.width)
}
inline double LaneData::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void LaneData::_internal_set_width(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// repeated .TempoMapQuery.LaneConnection connections = 5;
inline int LaneData::_internal_connections_size() const {
  return _internal_connections().size();
}
inline int LaneData::connections_size() const {
  return _internal_connections_size();
}
inline void LaneData::clear_connections() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connections_.Clear();
}
inline ::TempoMapQuery::LaneConnection* LaneData::mutable_connections(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.LaneData.connections)
  return _internal_mutable_connections()->Mutable(index);
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneConnection>* LaneData::mutable_connections()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMapQuery.LaneData.connections)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_connections();
}
inline const ::TempoMapQuery::LaneConnection& LaneData::connections(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneData.connections)
  return _internal_connections().Get(index);
}
inline ::TempoMapQuery::LaneConnection* LaneData::add_connections() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TempoMapQuery::LaneConnection* _add = _internal_mutable_connections()->Add();
  // @@protoc_insertion_point(field_add:TempoMapQuery.LaneData.connections)
  return _add;
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneConnection>& LaneData::connections() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMapQuery.LaneData.connections)
  return _internal_connections();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneConnection>&
LaneData::_internal_connections() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connections_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneConnection>*
LaneData::_internal_mutable_connections() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.connections_;
}

// -------------------------------------------------------------------

// LaneDataResponse

// repeated .TempoMapQuery.LaneData lanes = 1;
inline int LaneDataResponse::_internal_lanes_size() const {
  return _internal_lanes().size();
}
inline int LaneDataResponse::lanes_size() const {
  return _internal_lanes_size();
}
inline void LaneDataResponse::clear_lanes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lanes_.Clear();
}
inline ::TempoMapQuery::LaneData* LaneDataResponse::mutable_lanes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.LaneDataResponse.lanes)
  return _internal_mutable_lanes()->Mutable(index);
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneData>* LaneDataResponse::mutable_lanes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMapQuery.LaneDataResponse.lanes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_lanes();
}
inline const ::TempoMapQuery::LaneData& LaneDataResponse::lanes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneDataResponse.lanes)
  return _internal_lanes().Get(index);
}
inline ::TempoMapQuery::LaneData* LaneDataResponse::add_lanes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TempoMapQuery::LaneData* _add = _internal_mutable_lanes()->Add();
  // @@protoc_insertion_point(field_add:TempoMapQuery.LaneDataResponse.lanes)
  return _add;
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneData>& LaneDataResponse::lanes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMapQuery.LaneDataResponse.lanes)
  return _internal_lanes();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneData>&
LaneDataResponse::_internal_lanes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lanes_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::LaneData>*
LaneDataResponse::_internal_mutable_lanes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.lanes_;
}

// -------------------------------------------------------------------

// ZoneDataRequest

// .TempoMapQuery.TagFilter tag_filter = 1;
inline bool ZoneDataRequest::has_tag_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tag_filter_ != nullptr);
  return value;
}
inline void ZoneDataRequest::clear_tag_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tag_filter_ != nullptr) _impl_.tag_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TempoMapQuery::TagFilter& ZoneDataRequest::_internal_tag_filter() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TempoMapQuery::TagFilter* p = _impl_.tag_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::TempoMapQuery::TagFilter&>(::TempoMapQuery::_TagFilter_default_instance_);
}
inline const ::TempoMapQuery::TagFilter& ZoneDataRequest::tag_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.ZoneDataRequest.tag_filter)
  return _internal_tag_filter();
}
inline void ZoneDataRequest::unsafe_arena_set_allocated_tag_filter(::TempoMapQuery::TagFilter* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.tag_filter_);
  }
  _impl_.tag_filter_ = reinterpret_cast<::TempoMapQuery::TagFilter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TempoMapQuery.ZoneDataRequest.tag_filter)
}
inline ::TempoMapQuery::TagFilter* ZoneDataRequest::release_tag_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TempoMapQuery::TagFilter* released = _impl_.tag_filter_;
  _impl_.tag_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(released);
  released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TempoMapQuery::TagFilter* ZoneDataRequest::unsafe_arena_release_tag_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TempoMapQuery.ZoneDataRequest.tag_filter)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TempoMapQuery::TagFilter* temp = _impl_.tag_filter_;
  _impl_.tag_filter_ = nullptr;
  return temp;
}
inline ::TempoMapQuery::TagFilter* ZoneDataRequest::_internal_mutable_tag_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tag_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::TempoMapQuery::TagFilter>(GetArena());
    _impl_.tag_filter_ = reinterpret_cast<::TempoMapQuery::TagFilter*>(p);
  }
  return _impl_.tag_filter_;
}
inline ::TempoMapQuery::TagFilter* ZoneDataRequest::mutable_tag_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TempoMapQuery::TagFilter* _msg = _internal_mutable_tag_filter();
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.ZoneDataRequest.tag_filter)
  return _msg;
}
inline void ZoneDataRequest::set_allocated_tag_filter(::TempoMapQuery::TagFilter* value) {
  ::google::protobuf_tempo::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::TempoMapQuery::TagFilter*>(_impl_.tag_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf_tempo::Arena* submessage_arena = reinterpret_cast<::TempoMapQuery::TagFilter*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_tempo::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tag_filter_ = reinterpret_cast<::TempoMapQuery::TagFilter*>(value);
  // @@protoc_insertion_point(field_set_allocated:TempoMapQuery.ZoneDataRequest.tag_filter)
}

// .TempoScripting.Vector center = 2;
inline bool ZoneDataRequest::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline const ::TempoScripting::Vector& ZoneDataRequest::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TempoScripting::Vector* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::TempoScripting::Vector&>(::TempoScripting::_Vector_default_instance_);
}
inline const ::TempoScripting::Vector& ZoneDataRequest::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.ZoneDataRequest.center)
  return _internal_center();
}
inline void ZoneDataRequest::unsafe_arena_set_allocated_center(::TempoScripting::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::TempoScripting::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TempoMapQuery.ZoneDataRequest.center)
}
inline ::TempoScripting::Vector* ZoneDataRequest::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TempoScripting::Vector* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(released);
  released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_tempo::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TempoScripting::Vector* ZoneDataRequest::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TempoMapQuery.ZoneDataRequest.center)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TempoScripting::Vector* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::TempoScripting::Vector* ZoneDataRequest::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::TempoScripting::Vector>(GetArena());
    _impl_.center_ = reinterpret_cast<::TempoScripting::Vector*>(p);
  }
  return _impl_.center_;
}
inline ::TempoScripting::Vector* ZoneDataRequest::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TempoScripting::Vector* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.ZoneDataRequest.center)
  return _msg;
}
inline void ZoneDataRequest::set_allocated_center(::TempoScripting::Vector* value) {
  ::google::protobuf_tempo::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf_tempo::MessageLite*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf_tempo::Arena* submessage_arena = reinterpret_cast<::google::protobuf_tempo::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_tempo::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.center_ = reinterpret_cast<::TempoScripting::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:TempoMapQuery.ZoneDataRequest.center)
}

// double radius = 3;
inline void ZoneDataRequest::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.radius_ = 0;
}
inline double ZoneDataRequest::radius() const {
  // @@protoc_insertion_point(field_get:TempoMapQuery.ZoneDataRequest.radius)
  return _internal_radius();
}
inline void ZoneDataRequest::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.ZoneDataRequest.radius)
}
inline double ZoneDataRequest::_internal_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.radius_;
}
inline void ZoneDataRequest::_internal_set_radius(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.radius_ = value;
}

// -------------------------------------------------------------------

// ZoneConnection

// int32 id = 1;
inline void ZoneConnection::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t ZoneConnection::id() const {
  // @@protoc_insertion_point(field_get:TempoMapQuery.ZoneConnection.id)
  return _internal_id();
}
inline void ZoneConnection::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.ZoneConnection.id)
}
inline ::int32_t ZoneConnection::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void ZoneConnection::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// ZoneData

// int32 id = 1;
inline void ZoneData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t ZoneData::id() const {
  // @@protoc_insertion_point(field_get:TempoMapQuery.ZoneData.id)
  return _internal_id();
}
inline void ZoneData::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.ZoneData.id)
}
inline ::int32_t ZoneData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void ZoneData::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// repeated string tags = 2;
inline int ZoneData::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int ZoneData::tags_size() const {
  return _internal_tags_size();
}
inline void ZoneData::clear_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_.Clear();
}
inline std::string* ZoneData::add_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:TempoMapQuery.ZoneData.tags)
  return _s;
}
inline const std::string& ZoneData::tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.ZoneData.tags)
  return _internal_tags().Get(index);
}
inline std::string* ZoneData::mutable_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.ZoneData.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void ZoneData::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.ZoneData.tags)
}
inline void ZoneData::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TempoMapQuery.ZoneData.tags)
}
inline void ZoneData::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TempoMapQuery.ZoneData.tags)
}
inline void ZoneData::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TempoMapQuery.ZoneData.tags)
}
inline void ZoneData::set_tags(int index, absl_tempo::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:TempoMapQuery.ZoneData.tags)
}
inline void ZoneData::add_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:TempoMapQuery.ZoneData.tags)
}
inline void ZoneData::add_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:TempoMapQuery.ZoneData.tags)
}
inline void ZoneData::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TempoMapQuery.ZoneData.tags)
}
inline void ZoneData::add_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TempoMapQuery.ZoneData.tags)
}
inline void ZoneData::add_tags(absl_tempo::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:TempoMapQuery.ZoneData.tags)
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
ZoneData::tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMapQuery.ZoneData.tags)
  return _internal_tags();
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
ZoneData::mutable_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMapQuery.ZoneData.tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tags();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<std::string>&
ZoneData::_internal_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<std::string>*
ZoneData::_internal_mutable_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tags_;
}

// repeated .TempoScripting.Vector boundary_points = 4;
inline int ZoneData::_internal_boundary_points_size() const {
  return _internal_boundary_points().size();
}
inline int ZoneData::boundary_points_size() const {
  return _internal_boundary_points_size();
}
inline ::TempoScripting::Vector* ZoneData::mutable_boundary_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.ZoneData.boundary_points)
  return _internal_mutable_boundary_points()->Mutable(index);
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>* ZoneData::mutable_boundary_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMapQuery.ZoneData.boundary_points)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_boundary_points();
}
inline const ::TempoScripting::Vector& ZoneData::boundary_points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.ZoneData.boundary_points)
  return _internal_boundary_points().Get(index);
}
inline ::TempoScripting::Vector* ZoneData::add_boundary_points() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TempoScripting::Vector* _add = _internal_mutable_boundary_points()->Add();
  // @@protoc_insertion_point(field_add:TempoMapQuery.ZoneData.boundary_points)
  return _add;
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>& ZoneData::boundary_points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMapQuery.ZoneData.boundary_points)
  return _internal_boundary_points();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>&
ZoneData::_internal_boundary_points() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.boundary_points_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoScripting::Vector>*
ZoneData::_internal_mutable_boundary_points() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.boundary_points_;
}

// repeated .TempoMapQuery.ZoneConnection connections = 5;
inline int ZoneData::_internal_connections_size() const {
  return _internal_connections().size();
}
inline int ZoneData::connections_size() const {
  return _internal_connections_size();
}
inline void ZoneData::clear_connections() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connections_.Clear();
}
inline ::TempoMapQuery::ZoneConnection* ZoneData::mutable_connections(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.ZoneData.connections)
  return _internal_mutable_connections()->Mutable(index);
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneConnection>* ZoneData::mutable_connections()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMapQuery.ZoneData.connections)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_connections();
}
inline const ::TempoMapQuery::ZoneConnection& ZoneData::connections(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.ZoneData.connections)
  return _internal_connections().Get(index);
}
inline ::TempoMapQuery::ZoneConnection* ZoneData::add_connections() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TempoMapQuery::ZoneConnection* _add = _internal_mutable_connections()->Add();
  // @@protoc_insertion_point(field_add:TempoMapQuery.ZoneData.connections)
  return _add;
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneConnection>& ZoneData::connections() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMapQuery.ZoneData.connections)
  return _internal_connections();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneConnection>&
ZoneData::_internal_connections() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connections_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneConnection>*
ZoneData::_internal_mutable_connections() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.connections_;
}

// -------------------------------------------------------------------

// ZoneDataResponse

// repeated .TempoMapQuery.ZoneData zones = 1;
inline int ZoneDataResponse::_internal_zones_size() const {
  return _internal_zones().size();
}
inline int ZoneDataResponse::zones_size() const {
  return _internal_zones_size();
}
inline void ZoneDataResponse::clear_zones() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zones_.Clear();
}
inline ::TempoMapQuery::ZoneData* ZoneDataResponse::mutable_zones(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TempoMapQuery.ZoneDataResponse.zones)
  return _internal_mutable_zones()->Mutable(index);
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneData>* ZoneDataResponse::mutable_zones()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TempoMapQuery.ZoneDataResponse.zones)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_zones();
}
inline const ::TempoMapQuery::ZoneData& ZoneDataResponse::zones(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TempoMapQuery.ZoneDataResponse.zones)
  return _internal_zones().Get(index);
}
inline ::TempoMapQuery::ZoneData* ZoneDataResponse::add_zones() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::TempoMapQuery::ZoneData* _add = _internal_mutable_zones()->Add();
  // @@protoc_insertion_point(field_add:TempoMapQuery.ZoneDataResponse.zones)
  return _add;
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneData>& ZoneDataResponse::zones() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TempoMapQuery.ZoneDataResponse.zones)
  return _internal_zones();
}
inline const ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneData>&
ZoneDataResponse::_internal_zones() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zones_;
}
inline ::google::protobuf_tempo::RepeatedPtrField<::TempoMapQuery::ZoneData>*
ZoneDataResponse::_internal_mutable_zones() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.zones_;
}

// -------------------------------------------------------------------

// LaneAccessibilityRequest

// int32 from_id = 1;
inline void LaneAccessibilityRequest::clear_from_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.from_id_ = 0;
}
inline ::int32_t LaneAccessibilityRequest::from_id() const {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneAccessibilityRequest.from_id)
  return _internal_from_id();
}
inline void LaneAccessibilityRequest::set_from_id(::int32_t value) {
  _internal_set_from_id(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.LaneAccessibilityRequest.from_id)
}
inline ::int32_t LaneAccessibilityRequest::_internal_from_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.from_id_;
}
inline void LaneAccessibilityRequest::_internal_set_from_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.from_id_ = value;
}

// int32 to_id = 2;
inline void LaneAccessibilityRequest::clear_to_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.to_id_ = 0;
}
inline ::int32_t LaneAccessibilityRequest::to_id() const {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneAccessibilityRequest.to_id)
  return _internal_to_id();
}
inline void LaneAccessibilityRequest::set_to_id(::int32_t value) {
  _internal_set_to_id(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.LaneAccessibilityRequest.to_id)
}
inline ::int32_t LaneAccessibilityRequest::_internal_to_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.to_id_;
}
inline void LaneAccessibilityRequest::_internal_set_to_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.to_id_ = value;
}

// -------------------------------------------------------------------

// LaneAccessibilityResponse

// .TempoMapQuery.LaneAccessibility accessibility = 1;
inline void LaneAccessibilityResponse::clear_accessibility() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accessibility_ = 0;
}
inline ::TempoMapQuery::LaneAccessibility LaneAccessibilityResponse::accessibility() const {
  // @@protoc_insertion_point(field_get:TempoMapQuery.LaneAccessibilityResponse.accessibility)
  return _internal_accessibility();
}
inline void LaneAccessibilityResponse::set_accessibility(::TempoMapQuery::LaneAccessibility value) {
  _internal_set_accessibility(value);
  // @@protoc_insertion_point(field_set:TempoMapQuery.LaneAccessibilityResponse.accessibility)
}
inline ::TempoMapQuery::LaneAccessibility LaneAccessibilityResponse::_internal_accessibility() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::TempoMapQuery::LaneAccessibility>(_impl_.accessibility_);
}
inline void LaneAccessibilityResponse::_internal_set_accessibility(::TempoMapQuery::LaneAccessibility value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accessibility_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace TempoMapQuery


namespace google {
namespace protobuf_tempo {

template <>
struct is_proto_enum<::TempoMapQuery::LaneRelationship> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::TempoMapQuery::LaneRelationship>() {
  return ::TempoMapQuery::LaneRelationship_descriptor();
}
template <>
struct is_proto_enum<::TempoMapQuery::LaneAccessibility> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::TempoMapQuery::LaneAccessibility>() {
  return ::TempoMapQuery::LaneAccessibility_descriptor();
}

}  // namespace protobuf_tempo
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_TempoMapQuery_2fMapQueries_2eproto_2epb_2eh
